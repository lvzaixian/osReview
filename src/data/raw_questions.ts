import type { Question } from '../types';

export const rawQuestions: Question[] = [
    {
        id: "obj-intro-1",
        stem: "下列关于批处理系统的叙述中，正确的是\n①批处理系统允许多个用户与计算机直接交互\n②批处理系统分为单道批处理系统和多道批处理系统\n③中断技术使得多道批处理系统的I/O设备可与CPU并行工作",
        options: [
            { key: "A", text: "仅②、③" },
            { key: "B", text: "仅②" },
            { key: "C", text: "仅①、②" },
            { key: "D", text: "仅①、③" },
        ],
        answer: "A",
        type: "single",
        explain: "①错误，批处理系统的主要缺点就是无交互性（用户将作业提交后就无法干预）；②正确，分为单道（一次一个）和多道（内存中同时多个）；③正确，多道程序设计利用中断技术在I/O设备工作时释放CPU给其他作业，实现并行。因此正确的是②和③。",
        mnemonic: "类比：批处理就像“寄快递”📦，一旦发货（提交）就没法改地址（无交互）了。"
    },
    {
        id: "obj-intro-2",
        stem: "下列关于 CPU 模式的叙述中，正确的是",
        options: [
            { key: "A", text: "CPU处于用户态时只能执行特权指令" },
            { key: "B", text: "CPU处于内核态时只能执行特权指令" },
            { key: "C", text: "CPU处于用户态时只能执行非特权指令" },
            { key: "D", text: "CPU处于内核态时只能执行非特权指令" },
        ],
        answer: "C",
        type: "single",
        explain: "CPU分为用户态（目态）和内核态（管态）。用户态只能执行非特权指令（如加减乘除）；内核态可以执行特权指令（如I/O操作、清内存），也可以执行非特权指令。因此“CPU处于用户态时只能执行非特权指令”是正确的描述。",
        mnemonic: "身份隐喻：用户态是“平民”🚫，内核态是“皇帝”👑（特权指令只有皇帝能下旨）。"
    },
    {
        id: "obj-intro-3",
        stem: "本地用户通过键盘登录系统时，首先获得键盘输入信息的程序是",
        options: [
            { key: "A", text: "命令解释程序" },
            { key: "B", text: "中断处理程序" },
            { key: "C", text: "系统调用服务程序" },
            { key: "D", text: "用户登录程序" },
        ],
        answer: "B",
        type: "single",
        explain: "键盘按下时会产生硬件中断，CPU暂停当前工作转去执行中断处理程序。因此中断处理程序最先获得输入信息，然后才交给设备驱动或登录程序。",
        mnemonic: "动作逻辑：键盘一响⚡️，中断程序立刻抢过麦克风。"
    },
    {
        id: "obj-intro-4",
        stem: "下列关于系统调用的叙述中，正确的是\n①在执行系统调用服务程序的过程中，CPU处于内核态\n②操作系统通过提供系统调用避免用户程序直接访问外设\n③不同的操作系统为应用程序提供了统一的系统调用接口\n④系统调用是操作系统内核为应用程序提供服务的接口",
        options: [
            { key: "A", text: "仅①、④" },
            { key: "B", text: "仅②、③" },
            { key: "C", text: "仅①、②、④" },
            { key: "D", text: "仅①、③、④" },
        ],
        answer: "C",
        type: "single",
        explain: "①正确，系统调用进入内核态执行；②正确，通过接口访问硬件更安全；③正确，标准化接口（API）；④正确，是用户与内核的桥梁。通常认为①、②、④是系统调用最核心的特征。",
        mnemonic: "定义：系统调用 = 通往内核世界的唯一签证🛂。"
    },
    {
        id: "obj-intro-5",
        stem: "某单CPU系统中有输入和输出设备奱1台，现有3个并发执行的作业，每个作业的输入、计算和输出的时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执行，则执行完3个作业需要的时间最少是",
        options: [
            { key: "A", text: "15ms" },
            { key: "B", text: "17ms" },
            { key: "C", text: "22ms" },
            { key: "D", text: "27ms" },
        ],
        answer: "B",
        type: "single",
        explain: "利用流水线重叠执行。作业1: 2(I)+3(C)+4(O)=9ms。作业2不能立即I，需等作业1的I结束，但这里是并发，主要看瓶颈。画甘特图：J1: I(0-2) C(2-5) O(5-9); J2: I(2-4) C(5-8) O(9-13); J3: I(4-6) C(8-11) O(13-17)。总时间17ms。",
        mnemonic: "视觉记忆：画甘特图📊，首尾相接，最长的那段就是瓶颈。"
    },
    {
        id: "obj-intro-6",
        stem: "内部异常(内中断)可分为故障( fault)、陷阱( trap)和终止( abort)三类。下列有关内部异常的叙述中，错误的是",
        options: [
            { key: "A", text: "内部异常的产生与当前执行指令相关" },
            { key: "B", text: "内部异常的检测由CPU内部逻辑实现" },
            { key: "C", text: "内部异常的响应发生在指令执行过程中" },
            { key: "D", text: "内部异常处理后返回到发生异常的指令继续执行" },
        ],
        answer: "D",
        type: "single",
        explain: "内部异常（Exception）中，Fault（故障，如缺页）可恢复；Trap（陷阱，如系统调用）可恢复；Abort（终止，如硬件严重错误）不可恢复，不会返回原指令执行。因此“内部异常处理后返回到发生异常的指令继续执行”这一说法对于终止类异常是错误的。",
        mnemonic: "逻辑分类：故障和陷阱能“浪子回头”，只有终止（Abort）是直接“退学”🏫。"
    },
    {
        id: "obj-intro-7",
        stem: "下列选项中，会导致用户进程从用户态切换到内核态的操作是\n①整数除以零\n② sin()函数调用\n③read系统调用",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅①、③" },
            { key: "C", text: "仅②、③" },
            { key: "D", text: "①、②和③" },
        ],
        answer: "B",
        type: "single",
        explain: "①除零是异常，自动切内核态处理；②sin()是标准库函数，在用户态执行，不一定切内核；③read是系统调用，必须切内核态。会导致切换到内核态的是①和③。",
        mnemonic: "关键词：凡是“出错”（异常）或“求助OS”（系统调用），都得进内核🚨。"
    },
    {
        id: "obj-intro-8",
        stem: "从下面关于并发性的论述中选出一条正确的论述",
        options: [
            { key: "A", text: "并发性是指若干事件在同一时刻发生" },
            { key: "B", text: "并行性是指若干事件在不同时刻发生" },
            { key: "C", text: "并发性是指若干事件在同一时间间隔内发生" },
            { key: "D", text: "并发性是指若干事件在不同时间间隔内发生" },
        ],
        answer: "C",
        type: "single",
        explain: "并发（Concurrency）指宏观上同时（同一时间间隔内发生），微观上交替；并行（Parallelism）指同一时刻同时发生（需多核）。",
        mnemonic: "生活类比：并发 = 一个人轮流吃三个馒头；并行 = 三个人同时吃三个馒头🍔。"
    },
    {
        id: "obj-intro-9",
        stem: "执行系统调用的过程包括如下主要操作：\n①返回用户态\n②执行陷入(trap)指令\n③传递系统调用参数\n④执行相应的服务程序\n正确的执行顺序是",
        options: [
            { key: "A", text: "②→③→①→④" },
            { key: "B", text: "②→④→③→①" },
            { key: "C", text: "③→②→④→①" },
            { key: "D", text: "③→④→②→①" },
        ],
        answer: "C",
        type: "single",
        explain: "系统调用的执行顺序：首先③传递参数（告诉OS要做什么），然后②执行陷入指令（进入内核态），接着④执行相应的服务程序（OS完成任务），最后①返回用户态（控制权交还用户）。",
        mnemonic: "流程口诀：先说要什么（参数）→ 敲门进去（陷入）→ 办事（服务）→ 出门回家（返回用户态）🚪"
    },
    {
        id: "obj-intro-10",
        stem: "分时操作系统通常采用（）策略为用户服务",
        options: [
            { key: "A", text: "可靠性和安全性" },
            { key: "B", text: "时间片轮转" },
            { key: "C", text: "时间片加权分配" },
            { key: "D", text: "短作业优先" },
        ],
        answer: "B",
        type: "single",
        explain: "分时系统的核心特征是多个用户通过终端同时使用计算机，采用时间片轮转调度策略，每个用户轮流获得一小段CPU时间，让用户感觉独占计算机。",
        mnemonic: "核心特征：分时 = 大家轮流用，每人一小段时间⏱️"
    },
    {
        id: "obj-intro-11",
        stem: "下列选项中，会导致进程从执行态变为就绪态的事件是",
        options: [
            { key: "A", text: "执行P(wait)操作" },
            { key: "B", text: "申请内存失败" },
            { key: "C", text: "启动I/O设备" },
            { key: "D", text: "被高优先级进程抢占" },
        ],
        answer: "D",
        type: "single",
        explain: "执行态 -> 就绪态：只有两种情况，1. 时间片用完；2. 被更高优先级抢占。其他情况如申请资源失败、启动I/O等都会导致进程进入阻塞态。",
        mnemonic: "条件判断：如果是“被迫”停下（时间到/被抢），就去排队（就绪）；如果是“主动”请求（I/O），就去睡觉（阻塞）💤。"
    },
    {
        id: "obj-intro-12",
        stem: "下列由当前线程引起的事件或执行的操作中，可能导致该线程由执行态变为就绪态的是",
        options: [
            { key: "A", text: "键盘输入" },
            { key: "B", text: "缺页异常" },
            { key: "C", text: "主动出让 CPU" },
            { key: "D", text: "执行信号量的wait()操作" },
        ],
        answer: "C",
        type: "single",
        explain: "主动出让CPU（Yield）会使线程从运行态回到就绪队列等待，不会进入阻塞态。其他如缺页、等待I/O或信号量都会导致线程阻塞。",
        mnemonic: "Yield操作：只是礼貌让座💺（回就绪），不是身体不适（去阻塞）。"
    },
    {
        id: "obj-intro-13",
        stem: "进程的基本状态（）可以由其他两种基本状态转变而来",
        options: [
            { key: "A", text: "就绪状态" },
            { key: "B", text: "执行状态" },
            { key: "C", text: "阻塞状态" },
            { key: "D", text: "新建状态" },
        ],
        answer: "A",
        type: "single",
        explain: "就绪状态可以由：1. 执行状态转来（时间片用完或被抢占）；2. 阻塞状态转来（等待的事件发生）。执行状态只能由就绪转来；阻塞状态只能由执行转来。",
        mnemonic: "就绪是[中转站]🚉，执行和阻塞都可以来这里排队。"
    },
    {
        id: "obj-intro-14",
        stem: "当一个进程（），就要退出等待队列而进入就绪队列",
        options: [
            { key: "A", text: "启动了外设" },
            { key: "B", text: "用完了规定的时间片" },
            { key: "C", text: "获得了所等待的资源" },
            { key: "D", text: "能得到所等待的处理器" },
        ],
        answer: "C",
        type: "single",
        explain: "进程在等待队列（阻塞状态）中等待某个事件或资源，当它获得所等待的资源后，就可以退出等待队列进入就绪队列，等待CPU调度执行。",
        mnemonic: "阻塞→就绪的条件：等的东西到了📬（I/O完成、资源到位）。"
    },
    {
        id: "obj-intro-15",
        stem: "下列事件或操作中，可能导致进程 P 由执行态变为阻塞态的是\n①进程 P 读文件\n②进程 P 的时间片用完\n③进程 P 申请外设\n④进程 P 执行信号量的 wait()操作",
        options: [
            { key: "A", text: "仅①、④" },
            { key: "B", text: "仅②、③" },
            { key: "C", text: "仅③、④" },
            { key: "D", text: "仅①、③、④" },
        ],
        answer: "D",
        type: "single",
        explain: "执行 -> 阻塞：通常是请求资源或等待事件。①读文件（等待磁盘I/O）；③申请外设（等待设备）；④Wait操作（信号量不足等待）。②时间片用完是变就绪。因此导致阻塞的是①、③、④。",
        mnemonic: "核心特征：凡是需要“等”外人（I/O、信号量）的，统统进阻塞区⏳。"
    },
    {
        id: "obj-intro-16",
        stem: "下列选项中，导致创建新进程的操作是\n①用户登录成功\n②设备分配\n③启动程序执行",
        options: [
            { key: "A", text: "仅①和②" },
            { key: "B", text: "仅②和③" },
            { key: "C", text: "仅①和③" },
            { key: "D", text: "①、②和③" },
        ],
        answer: "C",
        type: "single",
        explain: "①用户登录成功会创建shell进程；③启动程序就是创建进程。②设备分配只是给已有进程分配资源，不涉及创建新进程。",
        mnemonic: "登录和启动才是“生孩子”👶，分配设备只是“给玩具”。"
    },
    {
        id: "obj-intro-17",
        stem: "下列操作中，操作系统在创建新进程时，必须完成的是\n①申请空白的进程控制块\n②初始化进程控制块\n③设置进程状态为执行态",
        options: [
            { key: "A", text: "仅①" },
            { key: "B", text: "仅①、②" },
            { key: "C", text: "仅①、③" },
            { key: "D", text: "仅②、③" },
        ],
        answer: "B",
        type: "single",
        explain: "创建进程三步曲：申请PCB、初始化PCB、放入就绪队列。此时进程处于就绪态，而非执行态，需要等待调度。",
        mnemonic: "流程记忆：填表（PCB） -> 挂号（初始化） -> 候诊区排队（就绪）🏥。"
    },
    {
        id: "obj-intro-18",
        stem: "下列关于管道( Pipe )通信的叙述中，正确的是",
        options: [
            { key: "A", text: "一个管道可实现双向数据传输" },
            { key: "B", text: "管道的容量仅受磁盘容量大小限制" },
            { key: "C", text: "进程对管道进行读操作和写操作都可能被阻塞" },
            { key: "D", text: "一个管道只能有一个读进程或一个写进程对其操作" },
        ],
        answer: "C",
        type: "single",
        explain: "管道是半双工的（通常单向，或分时双向）；容量受限于内存缓冲区大小（非磁盘）；读空管道或写满管道都会阻塞。因此“进程对管道进行读操作和写操作都可能被阻塞”是正确的。",
        mnemonic: "物理特性：管道就像水管🚰，没水（读空）或水满（写满）都得停下来。"
    },
    {
        id: "obj-intro-19",
        stem: "下列关于线程的叙述中，错误的",
        options: [
            { key: "A", text: "内核级线程的调度由操作系统完成" },
            { key: "B", text: "操作系统为每个用户级线程建立一个线程控制块" },
            { key: "C", text: "用户级线程间的切换比内核级线程间的切换效率高" },
            { key: "D", text: "用户级线程可以在不支持内核级线程的操作系统上实现" },
        ],
        answer: "B",
        type: "single",
        explain: "用户级线程的TCB在用户空间，操作系统内核感知不到，因此OS不会为它建立线程控制块。",
        mnemonic: "黑户理论：用户级线程是OS眼里的“黑户”🕵️，根本没有户口本（TCB）。"
    },
    {
        id: "obj-intro-20",
        stem: "下列关于进程和线程的叙述中，正确的是",
        options: [
            { key: "A", text: "不管系统是否支持线程，进程都是资源分配的基本单位" },
            { key: "B", text: "线程是资源分配的基本单位，进程是调度的基本单位" },
            { key: "C", text: "系统级线程和用户级线程的切换都需要内核的支持" },
            { key: "D", text: "同一进程中的各个线程拥有各自不同的地址空间" },
        ],
        answer: "A",
        type: "single",
        explain: "这是经典定义：进程是资源分配的基本单位，线程是处理机调度的基本单位。不管系统是否支持线程，进程都是资源持有的主体。",
        mnemonic: "分工明确：进程管“钱”（资源💰），线程管“干活”（调度）。"
    },
    {
        id: "obj-intro-21",
        stem: "在支持多线程的系统中，进程P创建的若干线程不能共享的是",
        options: [
            { key: "A", text: "进程P的代码段" },
            { key: "B", text: "进程P中打开的文件" },
            { key: "C", text: "进程P的全局变量" },
            { key: "D", text: "进程P中某线程的栈指针" },
        ],
        answer: "D",
        type: "single",
        explain: "同一进程的线程共享代码、全局变量、打开的文件。但每个线程必须有自己独立的栈（Stack）来保存函数调用上下文。",
        mnemonic: "空间类比：代码和文件是“客厅”（公用），栈是“卧室”（私有🛏️）。"
    },
    {
        id: "obj-intro-22",
        stem: "使用TSL(Test and Set Lock)指令实现进程互斥的伪代码如下所示。下列与该实现机制相关的叙述中，正确的是\n```\ndo{\n...\nwhile(TSL(&lock));\ncritical section;\nlock=FALSE;\n...\n}while(TRUE);\n```",
        options: [
            { key: "A", text: "退出临界区的进程负责唤醒阻塞态进程" },
            { key: "B", text: "等待进入临界区的进程不会主动放弃CPU" },
            { key: "C", text: "上述伪代码满足“让权等待”的同步准则" },
            { key: "D", text: "while( TSL( &lock) )语句应在关中断状态下执行" },
        ],
        answer: "B",
        type: "single",
        explain: "while(TSL) 是典型的忙等待（Busy Waiting），进程在等待时不放弃CPU，一直循环检查，直到获取锁。",
        mnemonic: "TSL特征：死皮赖脸，一直敲门🚪（循环检查）直到开门。"
    },
    {
        id: "obj-intro-23",
        stem: "下列准则中，实现临界区互斥机制必须遵循的是\n①两个进程不能同时进入临界区\n②允许进程访问空闲的临界资源\n③进程等待进入临界区的时间是有限的\n④不能进入临界区的执行态进程立即放弃CPU",
        options: [
            { key: "A", text: "仅①、④" },
            { key: "B", text: "仅②、③" },
            { key: "C", text: "仅①、②、③" },
            { key: "D", text: "仅①、③、④" },
        ],
        answer: "C",
        type: "single",
        explain: "临界区准则：空闲让进、忙则等待、有限等待。让权等待是推荐的但非必须（如自旋锁就不让权）。因此必须遵循的是①互斥、②空闲让进、③有限等待。",
        mnemonic: "三大铁律：①只能进一个 ②没人赶紧进 ③别让人等太久⏳。"
    },
    {
        id: "obj-intro-24",
        stem: "有两个并发执行的进程P1和P2，共享初值为1的变量x。P1对x加1，P2对x减1。加1和减1操作的指令序列分别如下所示。两个操作完成后，x的值\n| 加1操作 | 说明 | 减1操作 | 说明 |\n|---|---|---|---|\n| load R1, x | 取x到寄存器R1中 | load R2, x | 取x到寄存器R2中 |\n| inc R1 | R1加1 | dec R2 | R2减1 |\n| store x, R1 | 将R1的内容存入x | store x, R2 | 将R2的内容存入x |",
        options: [
            { key: "A", text: "可能为-1或3" },
            { key: "B", text: "只能为1" },
            { key: "C", text: "可能为0、1或2" },
            { key: "D", text: "可能为-1、0、1或2" },
        ],
        answer: "C",
        type: "single",
        explain: "由于是并发执行，存在竞态条件。根据执行顺序不同：1)完全串行P1→P2或P2→P1：x=1；2)P1 load后P2全部执行完再P1继续：x=2；3)P2 load后P1全部执行完再P2继续：x=0。因此可能值为0、1、2。",
        mnemonic: "竞态条件：交叉执行可能产生意外结果，取决于谁先落笔(store)。"
    },
    {
        id: "obj-intro-25",
        stem: "设与某资源关联的信号量初值为3，当前值为1。若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是",
        options: [
            { key: "A", text: "0、1" },
            { key: "B", text: "1、0" },
            { key: "C", text: "1、2" },
            { key: "D", text: "2、0" },
        ],
        answer: "B",
        type: "single",
        explain: "信号量S。S > 0 表示可用资源数；S <= 0 表示|S|为等待进程数。这里初值3，当前1。说明消耗了2个，还剩1个可用。等待队列为0。",
        mnemonic: "数值含义：正数 = 库存量📦；负数 = 排队人数。"
    },
    {
        id: "obj-deadlock-1",
        stem: "死锁的预防是根据（）而采取措施实现的",
        options: [
            { key: "A", text: "配置足够的系统资源" },
            { key: "B", text: "使进程的推进顺序合理" },
            { key: "C", text: "破坏死锁的四个必要条件之一" },
            { key: "D", text: "防止系统进入不安全状态" },
        ],
        answer: "C",
        type: "single",
        explain: "死锁预防是通过破坏死锁产生的四个必要条件（互斥、占有并等待、不可抢占、循环等待）之一来实现的。A是资源充足但不能预防；B是死锁避免的思路；D也是死锁避免（银行家算法）的思路。",
        mnemonic: "死锁处理策略：预防=破坏条件🔨；避免=小心绕过🚧；检测=发现后处理🔍。"
    },
    {
        id: "obj-deadlock-2",
        stem: "死锁与安全状态的关系是",
        options: [
            { key: "A", text: "死锁状态有可能是安全状态" },
            { key: "B", text: "安全状态有可能成为死锁状态" },
            { key: "C", text: "不安全状态就是死锁状态" },
            { key: "D", text: "死锁状态一定是不安全状态" },
        ],
        answer: "D",
        type: "single",
        explain: "死锁一定是不安全状态；但不安全状态不一定会死锁（可能运气好没发生申请）。安全状态一定不会死锁。",
        mnemonic: "集合关系：死锁 ⊂ 不安全状态 ⚠️。（死锁是子集，安全是补集）。"
    },
    {
        id: "obj-deadlock-3",
        stem: "假设系统中有4个同类资源，进程P1、P2和P3需要的资源数分别为4、3和1，P1、P2和P3已申请到的资源数分别为2、1和0，则执行安全性检测算法的结果是",
        options: [
            { key: "A", text: "不存在安全序列，系统处于不安全状态" },
            { key: "B", text: "存在多个安全序列，系统处于安全状态" },
            { key: "C", text: "存在唯一安全序列P3、P1、P2，系统处于安全状态" },
            { key: "D", text: "存在唯一安全序列P3、P2、P1，系统处于安全状态" },
        ],
        answer: "A",
        type: "single",
        explain: "资源总4。P1占2（需4-2=2），P2占1（需3-1=2），P3占0（需1）。剩4-3=1。Avail=1。先给P3？P3需1，Avail1，可以。P3完，释放0，Avail=1。此时P1需2，P2需2，Avail只有1，都无法满足。系统不存在安全序列，处于不安全状态。",
        mnemonic: "计算陷阱：资源太少，无论先给谁，最后都凑不够“过路费”💸。"
    },
    {
        id: "obj-deadlock-4",
        stem: "下列关于银行家算法的叙述中，正确的是",
        options: [
            { key: "A", text: "银行家算法可以预防死锁" },
            { key: "B", text: "当系统处于安全状态时， 系统中一定无死锁进程" },
            { key: "C", text: "当系统处于不安全状态时，系统中一定会出现死锁进程" },
            { key: "D", text: "银行家算法破坏了死锁必要条件中的“请求和保持”条件" },
        ],
        answer: "B",
        type: "single",
        explain: "银行家算法是“避免”死锁（通过计算安全性），不是“预防”（通过破坏必要条件）。当系统处于安全状态时，系统中一定无死锁进程。",
        mnemonic: "算法目的：银行家算法就是个精明的会计🧮，只要账面（安全状态）平了，就绝不会破产（死锁）。"
    },
    {
        id: "obj-deadlock-5",
        stem: "现有3个同时到达的作业J1、J2、J3，它们的执行时间分别为T1、T2、T3，且T1<T2<T3 。系统按单道方式运行且采用短作业优先算法，则平均周转时间是",
        options: [
            { key: "A", text: "T1+T2+T3" },
            { key: "B", text: "(T1+T2+T3)/3" },
            { key: "C", text: "(3T1+2T2+T3)/3" },
            { key: "D", text: "(T1+2T2+3T3)/3" },
        ],
        answer: "C",
        type: "single",
        explain: "SJF（短作业优先）。顺序T1, T2, T3。周转时间：J1=T1; J2=T1+T2; J3=T1+T2+T3。平均=(3T1+2T2+T3)/3。",
        mnemonic: "公式规律：短作业优先 = 时间越短的，被加权的次数越多（倒序加权）📉。"
    },
    {
        id: "obj-deadlock-6",
        stem: "下列事件中，可能引起进程调度程序执行的是\n①中断处理结束\n②进程阻塞\n③进程执行结束\n④进程的时间片用完",
        options: [
            { key: "A", text: "仅①、③" },
            { key: "B", text: "仅②、④" },
            { key: "C", text: "仅③、④" },
            { key: "D", text: "①、②、③和④" },
        ],
        answer: "D",
        type: "single",
        explain: "调度发生在：1. I/O中断（可能唤醒高优先级）；2. 进程阻塞（自己放弃）；3. 结束（放弃）；4. 时间片完（强迫放弃）。这四种情况都会引起调度。",
        mnemonic: "触发时机：无论是“生老病死”（创建/结束）还是“暂停休息”（阻塞/时间片），都要喊调度员📢。"
    },
    {
        id: "obj-deadlock-7",
        stem: "假设4个作业到达系统的时刻和运行时间如下表所示。系统在t=2时开始作业调度。若分别采用先来先服务和短作业优先调度算法，则选中的作业分别是\n| 作业 | 到达时间t | 运行时间 |\n| ---- | --------- | -------- |\n| J1   | 0         | 3        |\n| J2   | 1         | 3        |\n| J3   | 1         | 2        |\n| J4   | 3         | 1        |",
        options: [
            { key: "A", text: "J2、J3" },
            { key: "B", text: "J1、J4" },
            { key: "C", text: "J2、J4" },
            { key: "D", text: "J1、J3" },
        ],
        answer: "D",
        type: "single",
        explain: "0时刻开始，FCFS选中最早到达的J1。若SJF，0时刻只有J1，选中J1，J1(3)跑完，此时J2(1,3), J3(1,2)已到，选最短的J3。所以选中的分别是J1和J3。",
        mnemonic: "算法差异：FCFS看谁来得早🕰️；SJF看谁干得快⚡️。"
    },
    {
        id: "obj-deadlock-8",
        stem: "进程P1、P2和P3进入就绪队列的时刻，优先值(越大优先权越高) 以及CPU的执行时间如下表所示。系统采用基于优先权的抢占式CPU调度算法，从0ms时刻开始进行调度，则P1、P2、P3的平均周转时间为\n| 进程名 | 进入就绪队列的时刻 | 优先数 | CPU的执行时间 |\n| ------ | ------------------ | ------ | ------------- |\n| p1     | 0ms                | 1      | 60ms          |\n| p2     | 20ms               | 10     | 42ms          |\n| p3     | 30ms               | 100    | 13ms          |",
        options: [
            { key: "A", text: "60ms" },
            { key: "B", text: "61ms" },
            { key: "C", text: "70ms" },
            { key: "D", text: "71ms" },
        ],
        answer: "B",
        type: "single",
        explain: "优先权抢占。0ms: P1(1)到，跑。20ms: P2(10)到，抢P1。P1剩40。30ms: P3(100)到，抢P2。P2剩(42-10)=32。P3跑13ms -> 43ms结束。P3周转=13。43ms: P2回CPU，跑32 -> 75ms结束。P2周转=55。75ms: P1回CPU，跑40 -> 115ms结束。P1周转=115。平均=(13+55+115)/3 = 61ms。",
        mnemonic: "抢占逻辑：强者上，弱者下。算时间时别忘了加上被抢占等待的那段空白⏳。"
    },
    {
        id: "obj-deadlock-9",
        stem: "进程P0、P1、P2和P3进入就绪队列的时刻、优先级(值越小优先权越高)及CPU执行时间如下表所示。若系统采用基于优先权的抢占式进程调度算法，则从0ms时刻开始调度，到4个进程都运行结束为止，发生进程调度的总次数为\n| 进程 | 进入就绪队列的时刻 | 优先数 | CPU执行时间 |\n| ---- | ------------------ | ------ | ----------- |\n| P0   | 0ms                | 15     | 100ms       |\n| P1   | 10ms               | 20     | 60ms        |\n| P2   | 10ms               | 10     | 20ms        |\n| P3   | 15ms               | 6      | 10ms        |",
        options: [
            { key: "A", text: "4" },
            { key: "B", text: "5" },
            { key: "C", text: "6" },
            { key: "D", text: "7" },
        ],
        answer: "C",
        type: "single",
        explain: "值越小优先级越高。P3(6) > P2(10) > P0(15) > P1(20)。0ms: P0 run; 10ms: P2抢占(1次); 15ms: P3抢占(1次); P3完换P2(1次); P2完换P0(1次); P0完换P1(1次)。初始P0也算1次调度。总共6次。",
        mnemonic: "计数规则：被抢占算一次，正常交接班🤝也算一次。"
    },
    {
        id: "obj-deadlock-10",
        stem: "某系统采用基于优先权的非抢占式进程调度策略，完成一次进程调度和进程切换的系统时间开销为1 µs。在T时刻就绪队列中有3个进程P1、P2和P3，其在就绪队列中的等待时间、需要的CPU时间和优先权如下表所示。若优先权值大的进程优先获得 CPU，从T时刻起系统开始进程调度，则系统的平均周转时间为\n| 进程 | 等待时间 | 需要的CPU时间 | 优先权 |\n| ---- | -------- | ------------- | ------ |\n| P1   | 30μs     | 12μs          | 10     |\n| P2   | 15μs     | 24μs          | 30     |\n| P3   | 18μs     | 36μs          | 20     |",
        options: [
            { key: "A", text: "54 µs" },
            { key: "B", text: "73 µs" },
            { key: "C", text: "74 µs" },
            { key: "D", text: "75 µs" },
        ],
        answer: "D",
        type: "single",
        explain: "非抢占。T时刻都在，优先权P2>P3>P1。顺序：P2 -> P3 -> P1。加上1us开销。P2周转 = 15+1+24 = 40。P3周转 = 18+1+24+1+36 = 80。P1周转 = 30+1+24+1+36+1+12 = 105。平均 = 75。",
        mnemonic: "计算细节：非抢占就是乖乖排队。记得把那 1µs 的系统开销加进每个人的等待账单🧾里。"
    },
    {
        id: "obj-deadlock-11",
        stem: "下列选项中，降低进程优先级的合理时机是",
        options: [
            { key: "A", text: "进程的时间片用完" },
            { key: "B", text: "进程刚完成I/O，进入就绪队列" },
            { key: "C", text: "进程长期处于就绪队列中" },
            { key: "D", text: "进程从就绪状态转为运行状态" },
        ],
        answer: "A",
        type: "single",
        explain: "时间片用完说明是CPU密集型进程，应降低其优先级，防止其长期垄断CPU，给I/O密集型进程更多机会。",
        mnemonic: "调节策略：占着茅坑（CPU）不走的，下次就把他优先级调低⬇️。"
    },
    {
        id: "obj-deadlock-12",
        stem: "某系统正在执行三个进程P1、P2和P3，各进程的计算(CPU)时间和I/O时间比例如下表所示。为提高系统资源利用率，合理的进程优先级设置应为\n| 进程 | 计算时间 | I/O时间 |\n| ---- | -------- | ------- |\n| P1   | 90%      | 10%     |\n| P2   | 50%      | 50%     |\n| P3   | 15%      | 85%     |",
        options: [
            { key: "A", text: "P1>P2>P3" },
            { key: "B", text: "P3>P2>P1" },
            { key: "C", text: "P2>P1=P3" },
            { key: "D", text: "P1>P2=P3" },
        ],
        answer: "B",
        type: "single",
        explain: "I/O密集型优先（提高设备利用率）。P3(85% I/O)最多，P2(50%)次之，P1(10%)最少。优先级 P3 > P2 > P1。",
        mnemonic: "优先级原则：谁喜欢频繁进出（I/O多），就优先照顾谁，别让他等急了💾。"
    },
    {
        id: "obj-deadlock-13",
        stem: "下列有关基于时间片的进程调度的叙述中，错误的是",
        options: [
            { key: "A", text: "时间片越短，进程切换的次数越多，系统开销也越大" },
            { key: "B", text: "当前进程的时间片用完后，该进程状态由执行态变为阻塞态" },
            { key: "C", text: "时钟中断发生后，系统会修改当前进程在时间片内的剩余时间" },
            { key: "D", text: "影响时间片大小的主要因素包括响应时间、系统开销和进程数量等" },
        ],
        answer: "B",
        type: "single",
        explain: "时间片用完，进程并未阻塞（它还想算），只是被迫让出CPU，状态变为“就绪态”排队等待下一次调度，而不是阻塞态。",
        mnemonic: "状态辨析：时间片到 = 重新排队🚶；阻塞 = 暂停业务🚫。"
    },
    {
        id: "obj-deadlock-14",
        stem: "下列内核的数据结构或程序中，分时系统实现时间片轮转调度需要使用的是\n①进程控制块\n②时钟中断处理程序\n③进程就绪队列\n④进程阻塞队列",
        options: [
            { key: "A", text: "仅②、③" },
            { key: "B", text: "仅①、④" },
            { key: "C", text: "仅①、②、③" },
            { key: "D", text: "仅①、②、④" },
        ],
        answer: "C",
        type: "single",
        explain: "分时系统时间片轮转需要：①PCB（记状态）、②时钟中断（计时）、③就绪队列（排队）。阻塞队列与时间片轮转机制本身无直接关系。",
        mnemonic: "组件需求：轮转调度就像“限时自助餐”，需要：餐券（PCB）、闹钟（时钟中断）⏰、排队栏杆（就绪队列）。"
    },
    {
        id: "obj-deadlock-15",
        stem: "下列调度算法中，不可能导致饥饿现象的是",
        options: [
            { key: "A", text: "时间片轮转" },
            { key: "B", text: "静态优先数调度" },
            { key: "C", text: "非抢占式短作业优先" },
            { key: "D", text: "抢占式短作业优先" },
        ],
        answer: "A",
        type: "single",
        explain: "时间片轮转（RR）公平分配CPU时间，每个进程都能轮流获得执行机会，因此不可能导致饥饿现象。",
        mnemonic: "绝对公平：RR算法就像转盘赌⚖️，只要还在转，每个人都有机会中奖（执行）。"
    },
    {
        id: "obj-deadlock-16",
        stem: "下列选项中，满足短任务优先且不会发生饥饿现象的调度算法是",
        options: [
            { key: "A", text: "先来先服务" },
            { key: "B", text: "高响应比优先" },
            { key: "C", text: "时间片轮转" },
            { key: "D", text: "非抢占式短任务优先" },
        ],
        answer: "B",
        type: "single",
        explain: "高响应比优先（HRRN）算法。响应比 = (等待时间+要求服务时间)/要求服务时间。等待时间越久响应比越高，防止了长作业饥饿；同时短任务分母小，响应比高，体现了短任务优先。",
        mnemonic: "综合考量：等待时间是分子（越等越重要），服务时间是分母（越短越优先）📈。"
    },
    {
        id: "obj-deadlock-17",
        stem: "一个进程的读磁盘操作完成后，操作系统针对该进程必做的是",
        options: [
            { key: "A", text: "修改进程状态为就绪态" },
            { key: "B", text: "降低进程优先级" },
            { key: "C", text: "给进程分配用户内存空间" },
            { key: "D", text: "增加进程时间片大小" },
        ],
        answer: "A",
        type: "single",
        explain: "读盘是I/O操作。完成后，中断处理程序会将该进程从阻塞态唤醒，变为就绪态，等待CPU调度。",
        mnemonic: "因果关系：I/O 完成 ✅ -> 唤醒进程 -> 回就绪队列。"
    },
    {
        id: "obj-deadlock-18",
        stem: "系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10 ms；就绪队列Q2 采用短进程优先调度算法；系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程；新创建的进程首先进入Q1；Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1、Q2为空，系统依次创建进程P1、P2后即开始进程调度，P1、P2需要的CPU时间分别为30 ms和20ms，则进程P1 、P2在系统中的平均等待时间为",
        options: [
            { key: "A", text: "25 ms" },
            { key: "B", text: "20 ms" },
            { key: "C", text: "15 ms" },
            { key: "D", text: "10 ms" },
        ],
        answer: "C",
        type: "single",
        explain: "Q1(RR, 10ms), Q2(SJF)。P1(30), P2(20)。P1先跑10ms降级去Q2；P2跑10ms降级去Q2。Q1空，Q2按SJF调度，P2(剩10) < P1(剩20)，P2先跑。P1总等待：0(进Q1)+10(等P2在Q1)+10(等P2在Q2) = 20。P2总等待：10(等P1在Q1)。平均等待 15ms。",
        mnemonic: "多级反馈：就像降级联赛⚽️，表现不好（时间片用完）就掉到下一级去踢（降级）。"
    },
    {
        id: "obj-deadlock-19",
        stem: "下列与进程有关的因素中，在设计多级反馈队列调度算法时需要考虑的是\n①就绪队列的数量\n②就绪队列的优先级\n③各就绪队列的调度算法\n④进程在就绪队列间的迁移条件",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅③、④" },
            { key: "C", text: "仅②、③、④" },
            { key: "D", text: "①、②、③和④" },
        ],
        answer: "D",
        type: "single",
        explain: "多级反馈队列设计要素包括：就绪队列的数量、各队列的优先级、各队列的调度算法、进程在就绪队列间的迁移条件。",
        mnemonic: "全要素：多级反馈设计 = 队列数 + 优先级 + 算法 + 迁移规则📝。"
    },
    {
        id: "obj-deadlock-20",
        stem: "若系统中有n(n≥2)个进程，每个进程均需要使用某类临界资源2个，则系统不会发生死锁所需的该类资源总数至少是",
        options: [
            { key: "A", text: "2" },
            { key: "B", text: "n" },
            { key: "C", text: "n+1" },
            { key: "D", text: "2n" },
        ],
        answer: "C",
        type: "single",
        explain: "死锁最坏情况：每个进程都拿了1个，还需要1个。N个进程占了N个资源。只要再多1个资源，就能让其中一个进程完成并释放。所以至少需要 N + 1 个资源。",
        mnemonic: "临界点计算：死锁极限 = N个进程各拿1个；破局关键 = 再多给1个资源💡。"
    },
    {
        id: "obj-deadlock-21",
        stem: "某计算机系统中有8台打印机，由K个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的K的最小值是",
        options: [
            { key: "A", text: "2" },
            { key: "B", text: "3" },
            { key: "C", text: "4" },
            { key: "D", text: "5" },
        ],
        answer: "C",
        type: "single",
        explain: "K个进程，每人要3个。死锁边缘是每人拿2个。资源总8。2K < 8 => K < 4。若K=4，每人2个，共8个，刚好分完且都无法推进，发生死锁。所以K最小值是4。",
        mnemonic: "数学模型：当 (需求-1) * 进程数 = 资源总数时，就是死锁的边缘💀。"
    },
    {
        id: "obj-deadlock-22",
        stem: "某系统有n台互斥使用的同类设备，三个并发进程分别需要3、4、5台设备，可确保系统不发生死锁的设备数m最小为",
        options: [
            { key: "A", text: "9" },
            { key: "B", text: "10" },
            { key: "C", text: "11" },
            { key: "D", text: "12" },
        ],
        answer: "B",
        type: "single",
        explain: "需求3,4,5。最坏占有：2,3,4。总共占了2+3+4=9个资源。此时只要再多1个资源给任意一个进程，它就能完成并释放。所以m最小为 9+1 = 10。",
        mnemonic: "公式记忆：Max需求减1求和，最后再加1➕。"
    },
    {
        id: "obj-deadlock-23",
        stem: "下列关于死锁的叙述中，正确的是\n①可以通过剥夺进程资源解除死锁\n②死锁的预防方法能确保系统不发生死锁\n③银行家算法可以判断系统是否处于死锁状态\n④当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态",
        options: [
            { key: "A", text: "仅②、③" },
            { key: "B", text: "仅①、②、④" },
            { key: "C", text: "仅①、②、③" },
            { key: "D", text: "仅①、③、④" },
        ],
        answer: "B",
        type: "single",
        explain: "①剥夺资源是解除死锁方法之一；②预防是破坏必要条件，能确保不发生；④死锁必然有循环等待，涉及进程肯定阻塞。③银行家算法是避免死锁，不是判断（检测）死锁状态。",
        mnemonic: "术语区分：预防=破坏条件；避免=银行家🧮；检测=资源图；解除=剥夺/撤销。"
    },
    {
        id: "obj-deadlock-24",
        stem: "系统中有3个不同的临界资源R1、R2和R3，被4个进程p1、p2、p3和p4共享。各进程对资源的需求：p1申请R1和R2，p2申请R2和R3，p3申请R1和R3，p4申请R2。若系统出现死锁，则处于死锁状态的进程数至少是",
        options: [
            { key: "A", text: "1" },
            { key: "B", text: "2" },
            { key: "C", text: "3" },
            { key: "D", text: "4" },
        ],
        answer: "C",
        type: "single",
        explain: "死锁至少形成环路。典型的三角环 P1->R2->P2->R3->P3->R1->P1。P4只申R2，不参与环。所以至少3个进程处于死锁状态。",
        mnemonic: "图形想象：死锁就是一个圈⭕️，至少得有3个人（本题语境）才能围成这个圈。"
    },
    {
        id: "obj-deadlock-25",
        stem: "若系统S1采用死锁避免方法，S2采用死锁检测方法。下列叙述中，正确的是\n①S1会限制用户申请资源的顺序，而S2不会\n②S1需要进程运行所需资源总量信息，而S2不需要\n③S1不会给可能导致死锁的进程分配资源，而S2会",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅②、③" },
            { key: "C", text: "仅①、③" },
            { key: "D", text: "①、②、③" },
        ],
        answer: "B",
        type: "single",
        explain: "S1避免（银行家）需要预知最大资源量，且会拒绝不安全申请；S2检测（不限制申请，只是定期查）。S1不会给可能导致死锁（不安全）的进程分配资源，而S2会（直到检测出死锁）。",
        mnemonic: "策略对比：避免 = 事前诸葛亮（查户口）；检测 = 事后诸葛亮（收拾残局）🕵️‍♂️。"
    },
    {
        id: "obj-memory-1",
        stem: "设内存的分配情况如图所示。若要申请一块40K的内存空间，采用最佳适应算法，则所得到的分区首址是",
        options: [
            { key: "A", text: "100K" },
            { key: "B", text: "190K" },
            { key: "C", text: "330K" },
            { key: "D", text: "410K" },
        ],
        answer: "C",
        type: "single",
        explain: "最佳适应（Best Fit）：找能满足要求且最小的空闲区。需40K。内存中空闲区有：80K、60K、102K。40K最适合放在60K的空闲区（起始地址330K处）。",
        mnemonic: "找坑原则：最佳适应 = 强迫症，非要找个大小最刚刚好的坑🕳️。"
    },
    {
        id: "obj-memory-2",
        stem: "某基于动态分区存储管理的计算机，其主存容量为55 MB(初始为空闲)，采用最佳适配(Best Fit)算法，分配和释放的顺序：分配15 MB，分配30 MB，释放15 MB，分配8 MB，分配6 MB。此时主存中最大空闲分区的大小是",
        options: [
            { key: "A", text: "7MB" },
            { key: "B", text: "9MB" },
            { key: "C", text: "10MB" },
            { key: "D", text: "15MB" },
        ],
        answer: "B",
        type: "single",
        explain: "55MB。顺序：1. 分15（剩40）；2. 分30（剩10）；3. 释15（空15, 占30, 空10）；4. 分8（Best Fit，找10的那个）：空15, 占30, 占8, 空2；5. 分6（Best Fit，找15的那个）：占6, 空9, 占30, 占8, 空2。最大空闲是9MB。",
        mnemonic: "操作模拟：像搭积木🧱一样，一步步画出内存图，Best Fit就是“填缝”。"
    },
    {
        id: "obj-memory-3",
        stem: "某计算机采用二级页表的分页存储管理方式，按字节编制，页大小为1KB，页表项大小为2B，逻辑地址结构如下。逻辑地址空间大小为2的16次方个页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是\n| 页目录号 | 页号 | 页内偏移量 |\n| -------- | ---- | ---------- |\n|          |      |            |",
        options: [
            { key: "A", text: "64" },
            { key: "B", text: "128" },
            { key: "C", text: "256" },
            { key: "D", text: "512" },
        ],
        answer: "B",
        type: "single",
        explain: "逻辑空间16位页（$2^{16}$页）。每页1KB。页表项2B。每页能存 1024/2 = 512个页表项。需页表项 $2^{16}$个。二级页表：顶级页目录。每个目录项指向一个二级页表（存512个项）。需 $2^{16} / 512 = 128$ 个目录项。",
        mnemonic: "计算捷径：页目录项数 = 总页数 / 单页能存的表项数➗。"
    },
    {
        id: "obj-memory-4",
        stem: "在一个段式存储管理系统中，段表内容如下表所示。一个逻辑地址为（2, 154B），它对应的物理地址是\n| 段号 | 段首地址 | 段长度 |\n| ---- | -------- | ------ |\n| 0    | 120K     | 40K    |\n| 1    | 760K     | 30K    |\n| 2    | 480K     | 20K    |\n| 3    | 370K     | 20K    |",
        options: [
            { key: "A", text: "120K+2B" },
            { key: "B", text: "480K+154B" },
            { key: "C", text: "30K+154B" },
            { key: "D", text: "480K+2B" },
        ],
        answer: "B",
        type: "single",
        explain: "逻辑地址(2, 154B)。段号2，偏移154。查表：段2基址480K，长度20K。154B < 20K，合法。物理地址 = 480K + 154B。",
        mnemonic: "寻址公式：物理地址 = 基址 + 偏移📍（前提是别越界）。"
    },
    {
        id: "obj-memory-5",
        stem: "动态重定位是在作业的（）中进行的",
        options: [
            { key: "A", text: "编译过程" },
            { key: "B", text: "装入过程" },
            { key: "C", text: "链接过程" },
            { key: "D", text: "执行过程" },
        ],
        answer: "D",
        type: "single",
        explain: "静态重定位在装入时完成（地址一次性转换）；动态重定位在执行时进行（每次访问时用重定位寄存器加基址转换）。动态重定位的优点是可以支持进程移动和内存紧凑。",
        mnemonic: "时机区分：静态=搬家时改地址📬；动态=每次寄快递时都查新地址🚚。"
    },
    {
        id: "obj-memory-6",
        stem: "在动态分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是",
        options: [
            { key: "A", text: "无上邻空闲区，也无下邻空闲区" },
            { key: "B", text: "有上邻空闲区，但无下邻空闲区" },
            { key: "C", text: "有下邻空闲区，但无上邻空闲区" },
            { key: "D", text: "有上邻空闲区，也有下邻空闲区" },
        ],
        answer: "D",
        type: "single",
        explain: "回收内存时，如果回收区上方有空闲区、下方也有空闲区，则会将这三个区域合并为一个大的空闲区。原本在空闲表中作为独立项的“下方空闲区”被合并掉，导致空闲区表项减1。",
        mnemonic: "消消乐原理：上下都空，三合一，空闲表项立刻少一条➖。"
    },
    {
        id: "obj-memory-7",
        stem: "下面的存储管理方案中，（）方式可以采用静态重定位",
        options: [
            { key: "A", text: "固定分区" },
            { key: "B", text: "可变分区" },
            { key: "C", text: "页式" },
            { key: "D", text: "段式" },
        ],
        answer: "A",
        type: "single",
        explain: "静态重定位要求程序装入后不能移动。固定分区由于分区位置固定，程序装入后位置不变，可以采用静态重定位。可变分区、页式、段式都可能需要移动或紧凑，需要动态重定位。",
        mnemonic: "静态重定位条件：位置固定不会动🔒（只有固定分区符合）。"
    },
    {
        id: "obj-memory-8",
        stem: "不会产生内部碎片的存储管理是",
        options: [
            { key: "A", text: "分页" },
            { key: "B", text: "分段" },
            { key: "C", text: "段页式" },
            { key: "D", text: "固定分区" },
        ],
        answer: "B",
        type: "single",
        explain: "分段管理方式按逻辑分段，无内部碎片（但有外部碎片）。分页有内部碎片。",
        mnemonic: "碎片口诀：分段像切菜（按需切，无内碎）；分页像装箱（定长装，有缝隙📦）。"
    },
    {
        id: "obj-memory-9",
        stem: "在不使用快表的情况下，基本段页式内存管理系统中，访问一条指令需要几次访问内存?",
        options: [
            { key: "A", text: "3" },
            { key: "B", text: "0" },
            { key: "C", text: "1" },
            { key: "D", text: "2" },
        ],
        answer: "A",
        type: "single",
        explain: "段页式访问需三次：1. 查段表；2. 查页表；3. 访问内存数据。",
        mnemonic: "访问次数：段页式 = 爬三层楼梯🧗（段表->页表->数据）。"
    },
    {
        id: "obj-memory-10",
        stem: "虚拟存储管理系统的基础是程序的（）理论",
        options: [
            { key: "A", text: "动态性" },
            { key: "B", text: "虚拟性" },
            { key: "C", text: "局部性" },
            { key: "D", text: "全局性" },
        ],
        answer: "C",
        type: "single",
        explain: "虚拟存储的理论基础是程序的局部性原理：时间局部性（最近访问的将来很可能再访问）和空间局部性（访问某位置后很可能访问附近位置）。正是因为局部性，才能用小的物理内存运行大程序。",
        mnemonic: "核心原理：局部性 = 程序员的习惯很固定🎯（老访问熟悉的地方）。"
    },
    {
        id: "obj-memory-11",
        stem: "对于采用虚拟内存管理方式的系统，下列关于进程虚拟地址空间的叙述中，错误的是",
        options: [
            { key: "A", text: "每个进程都有自已独立的虚拟地址空间" },
            { key: "B", text: "C语言中malloc()函数返回的是虚拟地址" },
            { key: "C", text: "进程对数据段和代码段可以有不同的访问权限" },
            { key: "D", text: "虚拟地址的大小由主存和硬盘的大小决定" },
        ],
        answer: "D",
        type: "single",
        explain: "虚拟地址大小由CPU寻址范围（如32位/64位）决定，不由主存和硬盘实际大小决定。每个进程有独立虚拟地址空间；malloc返回虚拟地址；数据段代码段权限不同。",
        mnemonic: "概念核心：虚拟地址只看CPU位数1️⃣0️⃣，不看你硬盘买多大。"
    },
    {
        id: "obj-memory-12",
        stem: "下列选项中，不会影响系统缺页率的是",
        options: [
            { key: "A", text: "页置换算法" },
            { key: "B", text: "工作集的大小" },
            { key: "C", text: "进程的数量" },
            { key: "D", text: "页缓冲队列的长度" },
        ],
        answer: "D",
        type: "single",
        explain: "缺页率受：页面置换算法、工作集的大小（分配页框数）、进程的局部性等影响。页缓冲队列长度主要用于优化写回效率，不直接影响缺页发生的概率。",
        mnemonic: "无关项：缓冲队列只是个“候车室”🚌，不决定谁会迟到（缺页）。"
    },
    {
        id: "obj-memory-13",
        stem: "在页式虚拟存储管理系统中，采用某些页面置换算法，会出现Belady异常现象，即进程的缺页次数会随着分配给该进程的页框个数的增加而增加。下列算法中：① LRU算法 ②FIFO算法 ③OPT算法，可能出现Belady异常现象的是",
        options: [
            { key: "A", text: "仅②" },
            { key: "B", text: "仅①、②" },
            { key: "C", text: "仅①、③" },
            { key: "D", text: "仅②、③" },
        ],
        answer: "A",
        type: "single",
        explain: "Belady异常：页框多了，缺页反而多了。只有FIFO（先进先出）算法会发生。LRU和OPT是堆栈类算法，不会发生。",
        mnemonic: "异常独享：Belady异常是FIFO算法的专属bug🐛。"
    },
    {
        id: "obj-memory-14",
        stem: "某进程访问的页 b 不在内存中，导致产生缺页异常，该缺页异常处理过程中不一定包含的操作是",
        options: [
            { key: "A", text: "淘汰内存中的页" },
            { key: "B", text: "建立页号与页框号的对应关系" },
            { key: "C", text: "将页 b 从外存读入内存" },
            { key: "D", text: "修改页表中页 b 对应的存在位" },
        ],
        answer: "A",
        type: "single",
        explain: "缺页处理不一定包含淘汰内存中的页。如果内存中有空闲页框，则直接调入，无需淘汰。",
        mnemonic: "逻辑陷阱：只有“满座”了才需要赶人（淘汰），有空座直接坐🪑。"
    },
    {
        id: "obj-memory-16",
        stem: "在缺页处理过程中，操作系统执行的操作可能是\n①修改页表 ②磁盘I/O ③分配页框",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅②" },
            { key: "C", text: "仅③" },
            { key: "D", text: "①、②、③" },
        ],
        answer: "D",
        type: "single",
        explain: "缺页处理过程中，操作系统可能需要执行：分配页框、磁盘I/O（调入页）、修改页表。",
        mnemonic: "全套服务：缺页处理 = 找地盘 + 搬运数据💾 + 登记造册（修页表）。"
    },
    {
        id: "obj-memory-17",
        stem: "某请求分页存储系统的页大小为4KB，按字节编址。系统给进程P分配2个固定的页框,并采用改进型Clock置换算法，进程P页表的部分内容如下表所示。若P访问虚拟地址为02A01H的存储单元，则经地址变换后得到的物理地址是\n| 页号 | 页框号 | 存在位(1:存在，0:不存在) | 访问位(1:访问，0:未访问) | 修改位(1:修改，0:未修改) |\n| ---- | ------ | ------------------------ | ------------------------ | ------------------------ |\n| …    | …      | …                        | …                        | …                        |\n| 2    | 20H    | 0                        | 0                        | 0                        |\n| 3    | 60H    | 1                        | 1                        | 0                        |\n| 4    | 80H    | 1                        | 1                        | 1                        |\n| …    | …      | …                        | …                        | …                        |",
        options: [
            { key: "A", text: "00A01H" },
            { key: "B", text: "20A01H" },
            { key: "C", text: "60A01H" },
            { key: "D", text: "80A01H" },
        ],
        answer: "C",
        type: "single",
        explain: "逻辑地址 02 A01H。低12位是偏移 A01H。高位是页号。根据答案推断题目意图应是访问页表中的某一项，结合页框号拼接。正确逻辑是：物理地址 = 对应页框号 + 偏移量。假设页号对应页框为60H，则物理地址为60A01H。",
        mnemonic: "拼接法：物理地址 = 页框号(拼) + 偏移量(凑)🧩。"
    },
    {
        id: "obj-memory-18",
        stem: "在采用二级页表的分页系统中，CPU页表基址寄存器中的内容是",
        options: [
            { key: "A", text: "当前进程的一级页表的起始虚拟地址" },
            { key: "B", text: "当前进程的一级页表的起始物理地址" },
            { key: "C", text: "当前进程的二级页表的起始虚拟地址" },
            { key: "D", text: "当前进程的二级页表的起始物理地址" },
        ],
        answer: "B",
        type: "single",
        explain: "页表基址寄存器（PTBR）必须存物理地址，因为硬件（MMU）访问内存时还没法用虚拟地址。",
        mnemonic: "硬件常识：寄存器里只存“真理”（物理地址📍），不存“幻想”（虚拟地址）。"
    },
    {
        id: "obj-memory-19",
        stem: "某计算机主存按字节编址，采用二级分页存储管理，地址结构如下所示。虚拟地址2050 1225H对应的页目录号、页号分别是\n| 页目录号（10位） | 页号（10）位 | 页内偏移（12位） |\n| ---------------- | ------------ | ---------------- |\n|                  |              |                  |",
        options: [
            { key: "A", text: "081H、101H" },
            { key: "B", text: "081H、401H" },
            { key: "C", text: "201H、101H" },
            { key: "D", text: "201H、401H" },
        ],
        answer: "A",
        type: "single",
        explain: "虚拟地址 2050 1225H。按结构切分：低12位是偏移 225H。中间10位是页号 101H。高10位是页目录号 081H。",
        mnemonic: "位操作：把16进制转2进制，按 10-10-12 的比例像切蛋糕🍰一样切开。"
    },
    {
        id: "obj-memory-20",
        stem: "在可变式分区存储管理中的紧凑技术可以",
        options: [
            { key: "A", text: "集中空闲区" },
            { key: "B", text: "增加主存容量" },
            { key: "C", text: "缩短访问周期" },
            { key: "D", text: "加速地址转换" },
        ],
        answer: "A",
        type: "single",
        explain: "紧凑（Compaction）通过移动内存中的作业，把分散的小空闲区拼成大空闲区，从而能够容纳新的作业，集中了空闲区。",
        mnemonic: "动作描述：紧凑 = 内存碎片大扫除🧹，把零散空地挤在一起。"
    },
    {
        id: "obj-memory-21",
        stem: "虚拟存储管理策略可以",
        options: [
            { key: "A", text: "扩大逻辑内存容量" },
            { key: "B", text: "扩大物理内存容量" },
            { key: "C", text: "扩大逻辑外存容量" },
            { key: "D", text: "扩大物理外存容量" },
        ],
        answer: "A",
        type: "single",
        explain: "虚拟存储器的核心目的：逻辑上扩充内存容量，让用户感觉到内存容量远大于实际物理内存。",
        mnemonic: "核心价值：虚存就是给用户画大饼🥞，让他以为内存无限大。"
    },
    {
        id: "obj-memory-22",
        stem: "一般情况下，请求分页存储管理方式中，页面大小增加一倍则缺页中断次数",
        options: [
            { key: "A", text: "增加" },
            { key: "B", text: "减少" },
            { key: "C", text: "不变" },
            { key: "D", text: "可能增加也可能减少" },
        ],
        answer: "B",
        type: "single",
        explain: "页面增大，每个页包含的内容更多，根据局部性原理，一次加载更多相关数据，缺页次数会减少（但页内碎片变大）。",
        mnemonic: "趋势判断：页面越大📄，一口吃得越多，需要张嘴（缺页）的次数就越少。"
    },
    {
        id: "obj-memory-23",
        stem: "下列选项中，属于多级页表优点的是",
        options: [
            { key: "A", text: "加快地址变换速度" },
            { key: "B", text: "减少缺页中断次数" },
            { key: "C", text: "减少页表项所占字节数" },
            { key: "D", text: "减少页表所占的连续内存空间" },
        ],
        answer: "D",
        type: "single",
        explain: "多级页表通过只加载部分页表到内存，且页表可以离散存放，解决了页表本身占用大片连续内存空间的问题。",
        mnemonic: "优点总结：多级页表 = 化整为零，不必非要找大片连续地皮🗺️。"
    },
    {
        id: "obj-memory-25",
        stem: "系统为某进程分配了4个页框，该进程已访问的页号序列为2、0、2、9、3、4、2、8、2、4、8、4、5。若进程要访问的下一页的页号为7，依据 LRU 算法，应淘汰页的页号是",
        options: [
            { key: "A", text: "2" },
            { key: "B", text: "3" },
            { key: "C", text: "4" },
            { key: "D", text: "8" },
        ],
        answer: "A",
        type: "single",
        explain: "LRU（最近最少使用）。页框4。访问序列：2,0,2,9,3,4,2,8,2,4,8,4,5。最后栈状态（从旧到新）：2,8,4,5。下一次访问7，淘汰最老的2。",
        mnemonic: "拟人化：LRU就是喜新厌旧，谁最久没理我，我就把谁踢走🦵。"
    },
    {
        id: "obj-io-1",
        stem: "文件系统中用（）管理文件。",
        options: [
            { key: "A", text: "作业控制块" },
            { key: "B", text: "外页表" },
            { key: "C", text: "目录" },
            { key: "D", text: "软硬件结合的方法" },
        ],
        answer: "C",
        type: "single",
        explain: "文件系统通过目录（Directory）来管理文件名和文件的映射。FCB（文件控制块）通常包含在目录项中。",
        mnemonic: "寻物指南：找文件就像查电话簿📖，那个“簿子”就是目录。"
    },
    {
        id: "obj-io-2",
        stem: "如果文件系统中有两个文件重名，不应采用（ ）。",
        options: [
            { key: "A", text: "单级目录结构" },
            { key: "B", text: "树型目录结构" },
            { key: "C", text: "二级目录结构" },
            { key: "D", text: "非循环图目录结构" },
        ],
        answer: "A",
        type: "single",
        explain: "单级目录整个系统只有一张表，不允许重名。多级/树型目录允许不同目录下重名。",
        mnemonic: "弊端：单级目录就像一个大通铺🛏️，名字一样会打架。"
    },
    {
        id: "obj-io-3",
        stem: "下列选项中，支持文件长度可变、随机访问的磁盘存储空间分配方式是( )。",
        options: [
            { key: "A", text: "索引分配" },
            { key: "B", text: "链接分配" },
            { key: "C", text: "连续分配" },
            { key: "D", text: "动态分区分配" },
        ],
        answer: "A",
        type: "single",
        explain: "索引分配支持随机访问（直接算索引），且由于是块分配，支持长度可变。连续分配支持随机但不易变长；链接分配变长但不支持随机。",
        mnemonic: "全能选手：索引分配 = 既能随机点歌🎤，又能随意切歌（变长）。"
    },
    {
        id: "obj-io-4",
        stem: "采用直接存取方法来读写硬盘上的物理记录时，效率最低的文件结构是( )。",
        options: [
            { key: "A", text: "连续文件" },
            { key: "B", text: "索引文件" },
            { key: "C", text: "链接文件" },
            { key: "D", text: "索引连续文件" },
        ],
        answer: "C",
        type: "single",
        explain: "链接文件（链表）要找第N块，必须从头遍历，随机存取效率最低。",
        mnemonic: "形象比喻：链接文件像糖葫芦🍡，想吃中间那颗，得先把前面的舔一遍。"
    },
    {
        id: "obj-io-5",
        stem: "在磁盘上容易导致存储碎片发生的物理文件结构是（ ）。",
        options: [
            { key: "A", text: "链接文件" },
            { key: "B", text: "连续文件" },
            { key: "C", text: "索引文件" },
            { key: "D", text: "索引和链接文件" },
        ],
        answer: "B",
        type: "single",
        explain: "连续文件要求物理块连续，类似于内存的可变分区分配，时间长了会产生外部碎片。",
        mnemonic: "缺点记忆：连续文件太霸道，占地必须连成片，容易产生外部碎片🗑️。"
    },
    {
        id: "obj-io-6",
        stem: "UNIX系统中对空闲磁盘存储空间采用( )方法管理。",
        options: [
            { key: "A", text: "位示图" },
            { key: "B", text: "空闲块成组链接" },
            { key: "C", text: "空闲块单向链接" },
            { key: "D", text: "空闲块表" },
        ],
        answer: "B",
        type: "single",
        explain: "UNIX经典成组链接法（Group Linking），结合了空闲表和链表的优点，管理空闲磁盘空间。",
        mnemonic: "系统特性：UNIX 特产 = 成组链接法🔗。"
    },
    {
        id: "obj-io-7",
        stem: "为支持CD-ROM中视频文件的快速随机播放，播放性能最好的文件数据块组织方式（ ）。",
        options: [
            { key: "A", text: "连续结构" },
            { key: "B", text: "链式结构" },
            { key: "C", text: "直接索引结构" },
            { key: "D", text: "多级索引结构" },
        ],
        answer: "A",
        type: "single",
        explain: "CD-ROM视频主要是一次写入、顺序读取。连续结构读取速度最快（磁头不跳），播放性能最好。",
        mnemonic: "场景适用：看电影🎬不能卡，连续存放速度最快。"
    },
    {
        id: "obj-io-8",
        stem: "若某文件系统索引节点(inode)中有直接地址项和间接地址项，则下列选项中，与单个文件长度无关的因素是( )。",
        options: [
            { key: "A", text: "索引节点的总数" },
            { key: "B", text: "间接地址索引的级数" },
            { key: "C", text: "地址项的个数" },
            { key: "D", text: "文件块大小" },
        ],
        answer: "A",
        type: "single",
        explain: "单个文件的最大长度取决于：地址项个数、间接级数、块大小。与系统能存储的索引节点总数（文件总数）无关。",
        mnemonic: "无关排除：单文件多大，看它自己的结构🏗️，不看仓库（系统）能装多少个文件。"
    },
    {
        id: "obj-io-9",
        stem: "一个系统，它的文件控制块占64B，一个磁盘块大小为1KB，采用一级目录。假定文件目录中有3200个目录项。问查找一个文件平均需要（ ）次访问磁盘。",
        options: [
            { key: "A", text: "50" },
            { key: "B", text: "54" },
            { key: "C", text: "100" },
            { key: "D", text: "200" },
        ],
        answer: "C",
        type: "single",
        explain: "一级目录。3200个目录项。每个64B。目录文件大小 = 3200 * 64B = 200KB。磁盘块1KB。目录占200块。顺序查找平均需遍历目录的一半 = 100块。",
        mnemonic: "数学期望：顺序查找🔍的平均工时 = 总量的一半。"
    },
    {
        id: "obj-io-10",
        stem: "某文件系统的簇（块）和磁盘扇区大小分别为1 KB和512B。若一个文件的大小为1026B，则系统分配给该文件的磁盘空间大小是( )。",
        options: [
            { key: "A", text: "1026B" },
            { key: "B", text: "1536B" },
            { key: "C", text: "1538B" },
            { key: "D", text: "2048B" },
        ],
        answer: "D",
        type: "single",
        explain: "簇（块）大小1KB。文件1026B = 1024B + 2B。需占2个簇 = 2KB = 2048B。",
        mnemonic: "强迫症规则：哪怕只多出 1 bit，也要霸占整整一个房间（簇）🏠。"
    },
    {
        id: "obj-io-11",
        stem: "下列选项中，可用于文件系统管理空闲磁盘块的数据结构是( )。\n①位图 ②索引节点 ③空闲磁盘块链IV.文件分配表(FAT)",
        options: [
            { key: "A", text: "仅①②" },
            { key: "B", text: "仅①③④" },
            { key: "C", text: "仅①③" },
            { key: "D", text: "仅②③④" },
        ],
        answer: "B",
        type: "single",
        explain: "管理空闲块的数据结构包括：位图、空闲链表、FAT（FAT表中空闲标记）。索引节点是用于管理被占用的文件的元数据。",
        mnemonic: "排除法：inode 是管“有人”的房子的，不管空房子（空闲块）🚫。"
    },
    {
        id: "obj-io-12",
        stem: "设文件索引节点中有7个地址项，其中4个地址项为直接地址索引，2个地址项是一级间接地址索引，1个地址项是二级间接地址索引，每个地址项大小为4字节，若磁盘索引块和磁盘数据块大小均为256字节，则可表示的单个文件的最大长度是（ ）。",
        options: [
            { key: "A", text: "33KB" },
            { key: "B", text: "519KB" },
            { key: "C", text: "1057KB" },
            { key: "D", text: "16513KB" },
        ],
        answer: "C",
        type: "single",
        explain: "4直接 + 2一级 + 1二级。块256B，地址4B -> 每块存64个地址。直接：4 * 256B = 1KB。一级：2 * 64 * 256B = 32KB。二级：1 * 64 * 64 * 256B = 1024KB。总计 1057KB。",
        mnemonic: "计算逻辑：像俄罗斯套娃🪆，一级套一级，算出总块数再乘块大小。"
    },
    {
        id: "obj-io-13",
        stem: "假设某个文件的索引节点已在内存，其他信息均在外存，为了访问该文件的某内容，直接寻址、一次间接、二次间接、三次间接分别需要几次访盘？（ ）",
        options: [
            { key: "A", text: "0,1,2,3" },
            { key: "B", text: "1,2,3,4" },
            { key: "C", text: "2,3,4,5" },
            { key: "D", text: "1,3,4,5" },
        ],
        answer: "B",
        type: "single",
        explain: "inode在内存。直接索引：访盘1次（读数据）。一级间接：访盘2次（读索引+读数据）。二级间接：访盘3次（读一索+读二索+读数据）。三级间接：访盘4次。",
        mnemonic: "规律总结：N级索引 = N次读索引 + 1次读数据📖。"
    },
    {
        id: "obj-io-14",
        stem: "某文件系统的目录项由文件名和索引节点号构成。若每个目录项长度为64字节，其中4个字节存放索引节点号，60个字节存放文件名，文件名由小写英文字母构成，则该文件系统能创建的文件数量的上限为( )。",
        options: [
            { key: "A", text: "2^26" },
            { key: "B", text: "2^32" },
            { key: "C", text: "2^60" },
            { key: "D", text: "2^64" },
        ],
        answer: "B",
        type: "single",
        explain: "限制文件数量通常是inode号的位数。4字节 = 32位。最多2^32个号。与文件名长度无关。",
        mnemonic: "瓶颈所在：户口本编号（inode号）只有32位，这就是天花板🔝。"
    },
    {
        id: "obj-io-15",
        stem: "现有一个容量为10GB的磁盘分区，磁盘空间以簇(Cluster)为单位进行分配，簇的大小为4KB，若采用位图法管理该分区的空闲空间，即用一位(bit)标识一个簇是否被分配，则存放该位图所需簇的个数为( )。",
        options: [
            { key: "A", text: "80" },
            { key: "B", text: "320" },
            { key: "C", text: "80K" },
            { key: "D", text: "320K" },
        ],
        answer: "A",
        type: "single",
        explain: "10GB分区。簇4KB。簇总数 = 10GB / 4KB = 2.5M个簇。位图需 2.5M bit。2.5M bit / 8 = 312.5 KB。位图占簇数 = 312.5KB / 4KB ≈ 78.1 -> 80个簇。",
        mnemonic: "计算步骤：先算总簇数，再把簇数变成 bit 位📉。"
    },
    {
        id: "obj-io-16",
        stem: "引入高速缓冲的主要目的是（ ）。",
        options: [
            { key: "A", text: "提高CPU的利用率" },
            { key: "B", text: "提高I/O设备的利用率" },
            { key: "C", text: "改善CPU和I/O设备之间速度不匹配的情况" },
            { key: "D", text: "节省内存" },
        ],
        answer: "C",
        type: "single",
        explain: "Cache（高速缓冲）主要为了缓和CPU和I/O设备之间速度不匹配的情况。",
        mnemonic: "调解员：Cache 就是 CPU 和 I/O 之间的缓冲垫🧘，防止快慢不均打架。"
    },
    {
        id: "obj-io-17",
        stem: "CPU输出数据的速度远远高于打印机的打印速度，为了解决这一矛盾，可采用（ ）。",
        options: [
            { key: "A", text: "并行技术" },
            { key: "B", text: "通道技术" },
            { key: "C", text: "缓冲技术" },
            { key: "D", text: "虚存技术" },
        ],
        answer: "C",
        type: "single",
        explain: "CPU快打印机慢，为了解决矛盾，采用缓冲技术（Buffer）或SPOOLing。",
        mnemonic: "慢设备救星：打印机🖨️太慢？SPOOLing 来帮忙假装它很快。"
    },
    {
        id: "obj-io-18",
        stem: "通道相当于小型处理机，它用于实现（ ）之间的信息传输。",
        options: [
            { key: "A", text: "内存与外设" },
            { key: "B", text: "CPU与外设" },
            { key: "C", text: "内存与外存" },
            { key: "D", text: "CPU与外存" },
        ],
        answer: "A",
        type: "single",
        explain: "通道（Channel）是独立I/O处理器，负责内存与外设间数据传输，解放CPU。",
        mnemonic: "角色扮演：通道 = 专业的搬运工👷，CPU = 只管发号施令的老板。"
    },
    {
        id: "obj-io-19",
        stem: "以时间换空间或者以空间换时间是操作系统的基本技术，以下属于以空间换时间的机制是( )。",
        options: [
            { key: "A", text: "SPOOLing" },
            { key: "B", text: "虚拟存储技术" },
            { key: "C", text: "通道技术" },
            { key: "D", text: "覆盖技术" },
        ],
        answer: "A",
        type: "single",
        explain: "SPOOLing（假脱机）利用磁盘空间模拟独占设备，让多个作业觉得都有打印机。是用空间（磁盘）换取了时间（不必等待打印机真打完）。",
        mnemonic: "核心思想：空间换时间⏳，用磁盘假装打印机。"
    },
    {
        id: "obj-io-20",
        stem: "通过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为（ ）。",
        options: [
            { key: "A", text: "存储设备" },
            { key: "B", text: "系统设备" },
            { key: "C", text: "用户设备" },
            { key: "D", text: "虚拟设备" },
        ],
        answer: "D",
        type: "single",
        explain: "SPOOLing技术将独占设备改造为共享设备，逻辑上称为“虚拟设备”。",
        mnemonic: "魔法效果：SPOOLing 把“私家车”（独占）变成了“公交车”（共享🚌）。"
    },
    {
        id: "obj-io-21",
        stem: "在（ ）I/O控制方式中，设备能直接与内存交换数据而不占用CPU。",
        options: [
            { key: "A", text: "轮询" },
            { key: "B", text: "中断" },
            { key: "C", text: "DMA" },
            { key: "D", text: "MMU" },
        ],
        answer: "C",
        type: "single",
        explain: "DMA（直接内存存取）直接在内存和设备间传数据，仅开始和结束需CPU干预。",
        mnemonic: "简写含义：DMA = Direct Memory Access = 直接往内存里搬🚛。"
    },
    {
        id: "obj-io-22",
        stem: "某系统中磁盘的磁道数为200(0~199)，磁头当前在184号磁道上。用户进程提出的磁盘访问请求对应的磁道号依次为184、 187、176、182、199。若采用最短寻道时间优先调度算法(SSTF)完成磁盘访问，则磁头移动的距离(磁道数)是( )。",
        options: [
            { key: "A", text: "37" },
            { key: "B", text: "38" },
            { key: "C", text: "41" },
            { key: "D", text: "42" },
        ],
        answer: "C",
        type: "single",
        explain: "SSTF（最短寻道）。当前184。请求：184, 187, 176, 182, 199。路径：184 -> 182(2) -> 187(5) -> 176(11) -> 199(23)。总移动距离：2+5+11+23 = 41。",
        mnemonic: "贪心逻辑：SSTF 就是个近视眼👓，只看得到离自己最近的那个。"
    },
    {
        id: "obj-io-23",
        stem: "在以下磁盘调度算法中，（ ）算法可能会随时改变移动臂的运动方向 。",
        options: [
            { key: "A", text: "最短寻道时间优先" },
            { key: "B", text: "扫描SCAN（双向扫描）" },
            { key: "C", text: "巡回扫描C-SCAN（单向扫描）" },
            { key: "D", text: "都不会" },
        ],
        answer: "A",
        type: "single",
        explain: "SSTF（最短寻道时间优先）算法只看最近的请求，可能会随时改变移动臂的运动方向，导致左右来回跳动。",
        mnemonic: "缺点描述：SSTF 像个无头苍蝇🪰，忽左忽右没定性。"
    },
    {
        id: "obj-io-24",
        stem: "一个计算机系统配置了2台同类绘图机和3台同类打印机。为了正确驱动这些设备，系统应该提供（ ）个设备驱动程序。",
        options: [
            { key: "A", text: "5" },
            { key: "B", text: "3" },
            { key: "C", text: "2" },
            { key: "D", text: "1" },
        ],
        answer: "C",
        type: "single",
        explain: "同类设备共用一个驱动。绘图机1个，打印机1个。共需2个设备驱动程序。",
        mnemonic: "归类法：同一种设备 = 同一个驱动💾，不需要每台机器都装一个。"
    },
    {
        id: "obj-io-25",
        stem: "磁盘调度的目的是为了缩短（ ）时间。",
        options: [
            { key: "A", text: "寻道" },
            { key: "B", text: "延迟" },
            { key: "C", text: "传送" },
            { key: "D", text: "启动" },
        ],
        answer: "A",
        type: "single",
        explain: "磁盘读写时间 = 寻道 + 延迟 + 传输。寻道（移动磁臂）时间占比最大，调度算法主要优化它。",
        mnemonic: "耗时大户：磁盘读写慢，全怪寻道（挪动磁头）太费时🐢。"
    },
    {
        id: "hw1-1",
        stem: "从下面关于并发性的论述中选出一条正确的论述( )。",
        options: [
            { key: "A", text: "并发性是指若干事件在同一时刻发生" },
            { key: "B", text: "并发性是指若干事件在不同时间间隔内发生" },
            { key: "C", text: "并行性是指若干事件在不同时刻发生" },
            { key: "D", text: "并发性是指若干事件在同一时间间隔内发生" },
        ],
        answer: "D",
        type: "single",
        explain: "并发：若干事件在同一时间间隔内发生（交替）。并行：同一时刻发生。",
        mnemonic: "微观视角：并发是排队打饭🍛，并行是大家一起吃。"
    },
    {
        id: "hw1-2",
        stem: "某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的输入、计算和输出的时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执行，则执行完3个作业需要的时间最少是( )。",
        options: [
            { key: "A", text: "27ms" },
            { key: "B", text: "15ms" },
            { key: "C", text: "22ms" },
            { key: "D", text: "17ms" },
        ],
        answer: "D",
        type: "single",
        explain: "利用流水线重叠执行。作业1: 2(I)+3(C)+4(O)=9ms。作业2不能立即I，需等作业1的I结束，但这里是并发，主要看瓶颈。画甘特图：J1: I(0-2) C(2-5) O(5-9); J2: I(2-4) C(5-8) O(9-13); J3: I(4-6) C(8-11) O(13-17)。总时间17ms。",
        mnemonic: "关键路径：流水作业不用全加，主要看最慢的那一环🐢。"
    },
    {
        id: "hw1-4",
        stem: "下列关于管道( Pipe )通信的叙述中，正确的是( )。",
        options: [
            { key: "A", text: "管道的容量仅受磁盘容量大小限制" },
            { key: "B", text: "一个管道只能有一个读进程或一个写进程对其操作" },
            { key: "C", text: "一个管道可实现双向数据传输" },
            { key: "D", text: "进程对管道进行读操作和写操作都可能被阻塞" },
        ],
        answer: "D",
        type: "single",
        explain: "管道通信机制：进程对管道进行读操作和写操作都可能被阻塞（读空阻塞，写满阻塞）。",
        mnemonic: "拥堵机制：管道就像单行道⛔️，前面堵了（满）或没车（空）都得停。"
    },
    {
        id: "hw1-5",
        stem: "下列选项中，导致创建新进程的操作是( )。\n    ①用户登录成功\n    ②设备分配\n    ③启动程序执行",
        options: [
            { key: "A", text: "仅①和②" },
            { key: "B", text: "仅②和③" },
            { key: "C", text: "①、②和③" },
            { key: "D", text: "仅①和③" },
        ],
        answer: "D",
        type: "single",
        explain: "①用户登录成功会创建shell进程；③启动程序就是创建进程。②设备分配只是给已有进程分配资源。",
        mnemonic: "概念区分：登录和启动是“生”👶，分配资源是“养”🍼。"
    },
    {
        id: "hw1-6",
        stem: "下列关于进程和线程的叙述中，正确的是( )。",
        options: [
            { key: "A", text: "同一进程中的各个线程拥有各自不同的地址空间" },
            { key: "B", text: "系统级线程和用户级线程的切换都需要内核的支持" },
            { key: "C", text: "线程是资源分配的基本单位，进程是调度的基本单位" },
            { key: "D", text: "不管系统是否支持线程，进程都是资源分配的基本单位" },
        ],
        answer: "D",
        type: "single",
        explain: "进程是资源分配的基本单位，不管是单线程还是多线程系统，资源主要分配给进程。",
        mnemonic: "产权归属：房子（资源）写的是爸爸（进程）的名字🏠。"
    },
    {
        id: "hw1-7",
        stem: "本地用户通过键盘登录系统时，首先获得键盘输入信息的程序是( )。",
        options: [
            { key: "A", text: "系统调用服务程序" },
            { key: "B", text: "中断处理程序" },
            { key: "C", text: "用户登录程序" },
            { key: "D", text: "命令解释程序" },
        ],
        answer: "B",
        type: "single",
        explain: "键盘按下时会产生硬件中断，CPU暂停当前工作转去执行中断处理程序。因此中断处理程序最先获得输入信息。",
        mnemonic: "优先级：硬件中断是急诊🚑，谁都得给它让路。"
    },
    {
        id: "hw1-8",
        stem: "下列准则中，实现临界区互斥机制必须遵循的是( )。\n    ①两个进程不能同时进入临界区\n    ②允许进程访问空闲的临界资源\n    ③进程等待进入临界区的时间是有限的\n    ④不能进入临界区的执行态进程立即放弃CPU",
        options: [
            { key: "A", text: "仅②、③" },
            { key: "B", text: "仅①、③、④" },
            { key: "C", text: "仅①、④" },
            { key: "D", text: "仅①、②、③" },
        ],
        answer: "D",
        type: "single",
        explain: "临界区互斥准则：①互斥、②空闲让进、③有限等待。让权等待非必须。",
        mnemonic: "基本礼仪：有人别进，没人请进，别让人干等⏳。"
    },
    {
        id: "hw1-9",
        stem: "在支持多线程的系统中，进程P创建的若干线程不能共享的是( )。",
        options: [
            { key: "A", text: "进程P的代码段" },
            { key: "B", text: "进程P中某线程的栈指针" },
            { key: "C", text: "进程P的全局变量" },
            { key: "D", text: "进程P中打开的文件" },
        ],
        answer: "B",
        type: "single",
        explain: "同一进程的线程共享代码、全局变量、打开的文件。但每个线程必须有自己独立的栈（Stack）来保存函数调用上下文，栈指针私有。",
        mnemonic: "隐私范围：私房钱（栈）藏自己口袋💰，家具（代码/全局）大家共用。"
    },
    {
        id: "hw1-10",
        stem: "下列事件或操作中，可能导致进程 P 由执行态变为阻塞态的是( )。\n\t①进程 P 读文件\n\t②进程 P 的时间片用完\n\t③进程 P 申请外设\n\t④进程 P 执行信号量的 wait()操作",
        options: [
            { key: "A", text: "仅①、④" },
            { key: "B", text: "仅③、④" },
            { key: "C", text: "仅①、③、④" },
            { key: "D", text: "仅②、③" },
        ],
        answer: "C",
        type: "single",
        explain: "主动请求且需等待的操作会导致进程变阻塞：①读文件（IO）；③申外设；④Wait。②时间片用完是变就绪。",
        mnemonic: "状态切换：因为自己想办事（I/O）而停下叫阻塞🛑；被别人赶下来（时间片）叫就绪。"
    },
    {
        id: "hw1-13",
        stem: "执行系统调用的过程包括如下主要操作:\n     ①返回用户态\n     ②执行陷入(trap)指令\n     ③传递系统调用参数\n     ④执行相应的服务程序\n     正确的执行顺序是( )",
        options: [
            { key: "A", text: "②→④→③→①" },
            { key: "B", text: "③→④→②→①" },
            { key: "C", text: "②→③→①→④" },
            { key: "D", text: "③→②→④→①" },
        ],
        answer: "D",
        type: "single",
        explain: "系统调用执行顺序：传递系统调用参数 -> 执行陷入(trap)指令 -> 执行相应的服务程序 -> 返回用户态。",
        mnemonic: "执行流：先递交申请（传参）-> 敲门（Trap）🚪 -> 办事（服务） -> 回家（返回）。"
    },
    {
        id: "hw1-14",
        stem: "下列选项中，会导致进程从执行态变为就绪态的事件是( )。",
        options: [
            { key: "A", text: "启动I/O设备" },
            { key: "B", text: "被高优先级进程抢占" },
            { key: "C", text: "执行P(wait)操作" },
            { key: "D", text: "申请内存失败" },
        ],
        answer: "B",
        type: "single",
        explain: "会导致进程从执行态变为就绪态的是：被高优先级进程抢占（被迫让出，但仍准备好运行）。A、C会变阻塞。",
        mnemonic: "场景模拟：领导（高优）来了，我只好站起来（回就绪）让座🛋️。"
    },
    {
        id: "hw1-15",
        stem: "有两个并发执行的进程P1和P2，共享初值为1的变量x。P1对x加1，P2对x减1。加1和减1操作的指令序列分别如下所示。两个操作完成后，x的值( )。",
        options: [
            { key: "A", text: "只能为1" },
            { key: "B", text: "可能为0、1或2" },
            { key: "C", text: "可能为-1或3" },
            { key: "D", text: "可能为-1、0、1或2" },
        ],
        answer: "B",
        type: "single",
        explain: "Race Condition。x=1。P1(加1), P2(减1)。若交替执行：P1读1, P2读1, P1写2, P2写0 -> 结果0。P1读1, P2读1, P2写0, P1写2 -> 结果2。正常串行结果1。所以0, 1, 2都有可能。",
        mnemonic: "竞态条件：没加锁🔒的并发就是玄学，结果全看运气🎲。"
    },
    {
        id: "hw1-16",
        stem: "进程的基本状态( )可以由其他两种基本状态转变而来。",
        options: [
            { key: "A", text: "新建状态" },
            { key: "B", text: "执行状态" },
            { key: "C", text: "就绪状态" },
            { key: "D", text: "阻塞状态" },
        ],
        answer: "C",
        type: "single",
        explain: "就绪态可由：新建（创建完成）、执行（时间片完）、阻塞（事件完成）转变而来。可以由其他两种基本状态转变而来的是就绪态。",
        mnemonic: "交通枢纽：就绪态是十字路口🚦，四面八方都往这儿汇。"
    },
    {
        id: "hw1-17",
        stem: "当一个进程( )，就要退出等待队列而进入就绪队列。",
        options: [
            { key: "A", text: "能得到所等待的处理器" },
            { key: "B", text: "启动了外设" },
            { key: "C", text: "用完了规定的时间片" },
            { key: "D", text: "获得了所等待的资源" },
        ],
        answer: "D",
        type: "single",
        explain: "退出等待（阻塞）进入就绪，说明获得了所等待的资源或事件发生。",
        mnemonic: "因果：等到了东西🎁，就不用睡了（阻塞），起来排队（就绪）。"
    },
    {
        id: "hw1-18",
        stem: "下列关于 CPU 模式的叙述中，正确的是( )。",
        options: [
            { key: "A", text: "CPU处于用户态时只能执行非特权指令" },
            { key: "B", text: "CPU处于内核态时只能执行特权指令" },
            { key: "C", text: "CPU处于内核态时只能执行非特权指令" },
            { key: "D", text: "CPU处于用户态时只能执行特权指令" },
        ],
        answer: "A",
        type: "single",
        explain: "CPU处于用户态时只能执行非特权指令。特权指令只能在内核态执行。",
        mnemonic: "权限红线：特权指令🚫是红线，用户态碰了就报警。"
    },
    {
        id: "hw1-19",
        stem: "下列关于线程的叙述中，错误的( )。",
        options: [
            { key: "A", text: "用户级线程可以在不支持内核级线程的操作系统上实现" },
            { key: "B", text: "内核级线程的调度由操作系统完成" },
            { key: "C", text: "操作系统为每个用户级线程建立一个线程控制块" },
            { key: "D", text: "用户级线程间的切换比内核级线程间的切换效率高" },
        ],
        answer: "C",
        type: "single",
        explain: "操作系统为每个用户级线程建立一个线程控制块是错误的，因为内核感知不到用户级线程。",
        mnemonic: "隐形人：用户级线程对内核来说是隐形的👻，没有档案（TCB）。"
    },
    {
        id: "hw1-20",
        stem: "下列操作中，操作系统在创建新进程时，必须完成的是( )。\n     ①申请空白的进程控制块\n     ②初始化进程控制块\n     ③设置进程状态为执行态",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅①" },
            { key: "C", text: "仅②、③" },
            { key: "D", text: "仅①、③" },
        ],
        answer: "A",
        type: "single",
        explain: "创建进程必须完成：①申请空白的进程控制块、②初始化进程控制块。此时尚未执行。",
        mnemonic: "出生证明：创建进程就是填那张 PCB 表格📝，还没开始干活。"
    },
    {
        id: "hw1-21",
        stem: "下列选项中，会导致用户进程从用户态切换到内核态的操作是( )。\n     ①整数除以零\n     ② sin()函数调用\n     ③read系统调用",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅①、③" },
            { key: "C", text: "仅②、③" },
            { key: "D", text: "①、②和③" },
        ],
        answer: "B",
        type: "single",
        explain: "会导致用户进程从用户态切换到内核态的操作：①整数除以零（异常）、③read系统调用。②sin()是库函数，在用户态执行。",
        mnemonic: "进内核条件：要么犯错（异常💥），要么求助（系统调用）。"
    },
    {
        id: "hw1-22",
        stem: "下列关于系统调用的叙述中，正确的是( )。\n     ①在执行系统调用服务程序的过程中，CPU处于内核态\n     ②操作系统通过提供系统调用避免用户程序直接访问外设\n     ③不同的操作系统为应用程序提供了统一的系统调用接口\n     ④系统调用是操作系统内核为应用程序提供服务的接口",
        options: [
            { key: "A", text: "仅①、②、④" },
            { key: "B", text: "仅①、④" },
            { key: "C", text: "仅①、③、④" },
            { key: "D", text: "仅②、③" },
        ],
        answer: "A",
        type: "single",
        explain: "①在执行系统调用服务程序的过程中，CPU处于内核态；②操作系统通过提供系统调用避免用户程序直接访问外设；④系统调用是操作系统内核为应用程序提供服务的接口。",
        mnemonic: "服务窗口：系统调用是OS开给用户的服务窗口🪟。"
    },
    {
        id: "hw1-23",
        stem: "下列由当前线程引起的事件或执行的操作中，可能导致该线程由执行态变为就绪态的是( )。",
        options: [
            { key: "A", text: "主动出让 CPU" },
            { key: "B", text: "缺页异常" },
            { key: "C", text: "键盘输入" },
            { key: "D", text: "执行信号量的wait()操作" },
        ],
        answer: "A",
        type: "single",
        explain: "可能导致该线程由执行态变为就绪态的是：主动出让 CPU。",
        mnemonic: "高风亮节：主动让出CPU🤝，我只是休息一下（就绪），不是卡住了（阻塞）。"
    },
    {
        id: "hw1-24",
        stem: "分时操作系统通常采用( )策略为用户服务。",
        options: [
            { key: "A", text: "时间片轮转" },
            { key: "B", text: "时间片加权分配" },
            { key: "C", text: "短作业优先" },
            { key: "D", text: "可靠性和安全性" },
        ],
        answer: "A",
        type: "single",
        explain: "分时操作系统通常采用时间片轮转策略，保证所有用户都能及时得到响应。",
        mnemonic: "分时特征：雨露均沾🌧️，每个人都有几秒钟展示时间。"
    },
    {
        id: "hw2-1",
        stem: "下列调度算法中，不可能导致饥饿现象的是( )。",
        options: [
            { key: "A", text: "非抢占式短作业优先" },
            { key: "B", text: "时间片轮转" },
            { key: "C", text: "抢占式短作业优先" },
            { key: "D", text: "静态优先数调度" },
        ],
        answer: "B",
        type: "single",
        explain: "时间片轮转（RR）公平分配CPU，每个进程轮流执行，不可能导致饥饿现象。",
        mnemonic: "反饥饿：轮着吃大锅饭🍲，谁也饿不着。"
    },
    {
        id: "hw2-4",
        stem: "下列事件中，可能引起进程调度程序执行的是( )。\n①中断处理结束\n②进程阻塞\n③进程执行结束\n④进程的时间片用完",
        options: [
            { key: "A", text: "仅②、④" },
            { key: "B", text: "仅①、③" },
            { key: "C", text: "仅③、④" },
            { key: "D", text: "①、②、③和④" },
        ],
        answer: "D",
        type: "single",
        explain: "引起进程调度的事件：中断处理结束、进程阻塞、进程执行结束、进程的时间片用完。全部都会触发调度。",
        mnemonic: "忙碌的调度员：只要状态一变🔀，调度员就得出来干活。"
    },
    {
        id: "hw2-5",
        stem: "现有3个同时到达的作业J1、J2、J3，它们的执行时间分别为T1、T2、T3，且T1<T2<T3。系统按单道方式运行且采用短作业优先算法，则平均周转时间是( )",
        options: [
            { key: "A", text: "(T1+2T2+3T3)/3" },
            { key: "B", text: "(3T1+2T2+T3)/3" },
            { key: "C", text: "T1+T2+T3" },
            { key: "D", text: "(T1+T2+T3)/3" },
        ],
        answer: "B",
        type: "single",
        explain: "SJF（短作业优先）。顺序T1, T2, T3。周转时间：J1=T1; J2=T1+T2; J3=T1+T2+T3。平均=(3T1+2T2+T3)/3。",
        mnemonic: "数学规律：越短的放越前面，总体等待时间就越短📉。"
    },
    {
        id: "hw2-6",
        stem: "下列与进程有关的因素中，在设计多级反馈队列调度算法时需要考虑的是( )。\n①就绪队列的数量\n②就绪队列的优先级\n③各就绪队列的调度算法\n④进程在就绪队列间的迁移条件",
        options: [
            { key: "A", text: "①、②、③和④" },
            { key: "B", text: "仅②、③、④" },
            { key: "C", text: "仅③、④" },
            { key: "D", text: "仅①、②" },
        ],
        answer: "A",
        type: "single",
        explain: "设计多级反馈队列调度算法时需要考虑：就绪队列的数量、优先级、各队列的调度算法、进程在就绪队列间的迁移条件。",
        mnemonic: "复杂设计：多级反馈 = 多个队列 + 动态优先级📶。"
    },
    {
        id: "hw2-7",
        stem: "死锁的预防是根据( )而采取措施实现的。",
        options: [
            { key: "A", text: "使进程的推进顺序合理" },
            { key: "B", text: "配置足够的系统资源" },
            { key: "C", text: "防止系统进入不安全状态" },
            { key: "D", text: "破坏死锁的四个必要条件之一" },
        ],
        answer: "D",
        type: "single",
        explain: "死锁的预防是根据破坏死锁的四个必要条件之一而采取措施实现的。",
        mnemonic: "釜底抽薪：预防死锁就是把“火”（必要条件）给抽掉🔥。"
    },
    {
        id: "hw2-10",
        stem: "一个进程的读磁盘操作完成后，操作系统针对该进程必做的是( )。",
        options: [
            { key: "A", text: "修改进程状态为就绪态" },
            { key: "B", text: "给进程分配用户内存空间" },
            { key: "C", text: "增加进程时间片大小" },
            { key: "D", text: "降低进程优先级" },
        ],
        answer: "A",
        type: "single",
        explain: "读磁盘操作完成后（IO结束），操作系统会将该进程状态从阻塞态修改为就绪态。",
        mnemonic: "状态流转：事办完了（IO结束）✅，就别在阻塞区占坑了，回就绪区去。"
    },
    {
        id: "hw2-11",
        stem: "若系统S1采用死锁避免方法，S2采用死锁检测方法。下列叙述中，正确的是( )。\n\t①S1会限制用户申请资源的顺序，而S2不会\n\t②S1需要进程运行所需资源总量信息，而S2不需要\n\t③S1不会给可能导致死锁的进程分配资源，而S2会",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅①、③" },
            { key: "C", text: "仅②、③" },
            { key: "D", text: "①、②、③" },
        ],
        answer: "C",
        type: "single",
        explain: "S1避免（银行家）需要预知进程运行所需资源总量信息，而S2检测不需要。S1不会给可能导致死锁的进程分配资源，而S2会。",
        mnemonic: "特点对比：避免法需要“知根知底”（预知总量）；检测法是“先斩后奏”🔪。"
    },
    {
        id: "hw2-12",
        stem: "下列内核的数据结构或程序中，分时系统实现时间片轮转调度需要使用的是( )。\n\t①进程控制块\n\t②时钟中断处理程序\n\t③进程就绪队列\n\t④进程阻塞队列",
        options: [
            { key: "A", text: "仅①、④" },
            { key: "B", text: "仅②、③" },
            { key: "C", text: "仅①、②、④" },
            { key: "D", text: "仅①、②、③" },
        ],
        answer: "D",
        type: "single",
        explain: "分时系统实现时间片轮转调度需要：①进程控制块、②时钟中断处理程序、③进程就绪队列。",
        mnemonic: "必备工具：轮转调度靠闹钟（时钟中断）⏰和排队栏（就绪队列）。"
    },
    {
        id: "hw2-13",
        stem: "死锁与安全状态的关系是( )。",
        options: [
            { key: "A", text: "死锁状态一定是不安全状态" },
            { key: "B", text: "安全状态有可能成为死锁状态" },
            { key: "C", text: "不安全状态就是死锁状态" },
            { key: "D", text: "死锁状态有可能是安全状态" },
        ],
        answer: "A",
        type: "single",
        explain: "死锁状态一定是不安全状态。",
        mnemonic: "真值逻辑：死锁 => 不安全⚠️。（逆否不一定成立）。"
    },
    {
        id: "hw2-14",
        stem: "下列选项中，降低进程优先级的合理时机是( )。",
        options: [
            { key: "A", text: "进程的时间片用完" },
            { key: "B", text: "进程长期处于就绪队列中" },
            { key: "C", text: "进程刚完成I/O，进入就绪队列" },
            { key: "D", text: "进程从就绪状态转为运行状态" },
        ],
        answer: "A",
        type: "single",
        explain: "进程的时间片用完，说明该进程是计算密集型，降低其优先级可以避免其长期占用CPU。",
        mnemonic: "惩罚机制：占着CPU不走的人，下次把他的VIP卡（优先级）没收💳。"
    },
    {
        id: "hw2-15",
        stem: "某系统有n台互斥使用的同类设备，三个并发进程分别需要3、4、5台设备，可确保系统不发生死锁的设备数n最小为( )。",
        options: [
            { key: "A", text: "10" },
            { key: "B", text: "12" },
            { key: "C", text: "9" },
            { key: "D", text: "11" },
        ],
        answer: "A",
        type: "single",
        explain: "n台设备，3进程分别需3,4,5。最坏占有2,3,4，共9个。确保不锁需9+1=10台。",
        mnemonic: "计算公式：总需求 = ∑(每人需求-1) + 1️⃣。"
    },
    {
        id: "hw2-18",
        stem: "下列有关基于时间片的进程调度的叙述中，错误的是( )。",
        options: [
            { key: "A", text: "影响时间片大小的主要因素包括响应时间、系统开销和进程数量等" },
            { key: "B", text: "时钟中断发生后，系统会修改当前进程在时间片内的剩余时间" },
            { key: "C", text: "当前进程的时间片用完后，该进程状态由执行态变为阻塞态" },
            { key: "D", text: "时间片越短，进程切换的次数越多，系统开销也越大" },
        ],
        answer: "C",
        type: "single",
        explain: "当前进程的时间片用完后，该进程状态由执行态变为就绪态，而不是阻塞态。",
        mnemonic: "误区纠正：时间到是“重新排队”🚶，不是“去睡觉”（阻塞）。"
    },
    {
        id: "hw2-19",
        stem: "下列关于银行家算法的叙述中，正确的是( )。",
        options: [
            { key: "A", text: "当系统处于不安全状态时，系统中一定会出现死锁进程" },
            { key: "B", text: "银行家算法破坏了死锁必要条件中的“请求和保持”条件" },
            { key: "C", text: "银行家算法可以预防死锁" },
            { key: "D", text: "当系统处于安全状态时，系统中一定无死锁进程" },
        ],
        answer: "D",
        type: "single",
        explain: "银行家算法通过避免系统进入不安全状态来防止死锁。当系统处于安全状态时，系统中一定无死锁进程。",
        mnemonic: "安全保证：只要按银行家的规矩办🧮，绝对不会破产（死锁）。"
    },
    {
        id: "hw2-20",
        stem: "下列选项中，满足短任务优先且不会发生饥饿现象的调度算法是( )。",
        options: [
            { key: "A", text: "先来先服务" },
            { key: "B", text: "非抢占式短任务优先" },
            { key: "C", text: "时间片轮转" },
            { key: "D", text: "高响应比优先" },
        ],
        answer: "D",
        type: "single",
        explain: "高响应比优先算法满足短任务优先（分母小响应比高）且不会发生饥饿现象（等待久响应比高）。",
        mnemonic: "双重优势：既照顾了急性子（短作业），也不冷落老实人（长作业）🤝。"
    },
    {
        id: "hw2-21",
        stem: "下列关于死锁的叙述中，正确的是( )。\n\t①可以通过剥夺进程资源解除死锁\n\t②死锁的预防方法能确保系统不发生死锁\n\t③银行家算法可以判断系统是否处于死锁状态\n\t④当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态",
        options: [
            { key: "A", text: "仅①、②、④" },
            { key: "B", text: "仅①、②、③" },
            { key: "C", text: "仅②、③" },
            { key: "D", text: "仅①、③、④" },
        ],
        answer: "A",
        type: "single",
        explain: "①可以通过剥夺进程资源解除死锁；②预防方法能确保不发生死锁；④死锁必然有两个或以上进程阻塞。",
        mnemonic: "特征记忆：死锁现场一定有一群人在傻等（阻塞🛑）。"
    },
    {
        id: "hw2-23",
        stem: "某系统采用基于优先权的非抢占式进程调度策略,完成一次进程调度和进程切换的系统时间开销为1 µs。在T时刻就绪队列中有3个进程P1、P2和P3，其在就绪队列中的等待时间、需要的CPU时间和优先权如下表所示。若优先权值大的进程优先获得 CPU，从T时刻起系统开始进程调度，则系统的平均周转时间为( )。",
        options: [
            { key: "A", text: "75 µs" },
            { key: "B", text: "73 µs" },
            { key: "C", text: "74 µs" },
            { key: "D", text: "54 µs" },
        ],
        answer: "A",
        type: "single",
        explain: "非抢占。T时刻都在，优先权P2>P3>P1。顺序：P2 -> P3 -> P1。加上1us开销。P2周转 = 15+1+24 = 40。P3周转 = 18+1+24+1+36 = 80。P1周转 = 30+1+24+1+36+1+12 = 105。平均 = 75。",
        mnemonic: "易错点：算周转时间别忘了加上那个 1µs 的过路费💸。"
    },
    {
        id: "hw2-25",
        stem: "系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10 ms;就绪队列Q2 采用短进程优先调度算法;系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程;新创建的进程首先进入Q1;Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1、Q2为空，系统依次创建进程P1、P2后即开始进程调度，P1、P2需要的CPU时间分别为30 ms和20ms，则进程P1 、P2在系统中的平均等待时间为( )。",
        options: [
            { key: "A", text: "10 ms" },
            { key: "B", text: "25 ms" },
            { key: "C", text: "15 ms" },
            { key: "D", text: "20 ms" },
        ],
        answer: "C",
        type: "single",
        explain: "P1(30), P2(20)。P1先跑10ms降级去Q2；P2跑10ms降级去Q2。Q1空，Q2按SJF调度，P2(剩10) < P1(剩20)，P2先跑。P1总等待：0(进Q1)+10(等P2在Q1)+10(等P2在Q2) = 20。P2总等待：10(等P1在Q1)。平均等待 15ms。",
        mnemonic: "过程模拟：想象两个人在不同优先级的柜台间跑来跑去🏃，把每次排队时间加起来。"
    },
    {
        id: "hw3-1",
        stem: "设内存的分配情况如图所示。若要申请一块40K的内存空间，采用最佳适应算法，则所得到的分区首址是( )。",
        options: [
            { key: "A", text: "100K" },
            { key: "B", text: "190K" },
            { key: "C", text: "330K" },
            { key: "D", text: "410K" },
        ],
        answer: "C",
        type: "single",
        explain: "最佳适应（Best Fit）：找能满足要求且最小的空闲区。需40K。内存中空闲区有：80K、60K、102K。40K最适合放在60K的空闲区（起始地址330K处）。",
        mnemonic: "强迫症：Best Fit 就是非要找个最紧身👕的穿，一点空隙都不想留。"
    },
    {
        id: "hw3-4",
        stem: "在一个段式存储管理系统中，段表内容如下表所示。一个逻辑地址为(2, 154B)，它对应的物理地址是( )。",
        options: [
            { key: "A", text: "120K+2B" },
            { key: "B", text: "480K+154B" },
            { key: "C", text: "30K+154B" },
            { key: "D", text: "480K+2B" },
        ],
        answer: "B",
        type: "single",
        explain: "逻辑地址(2, 154B)。段号2，偏移154。查表：段2基址480K，长度20K。154B < 20K，合法。物理地址 = 480K + 154B。",
        mnemonic: "基本公式：物理地址 = 段基址 + 段内偏移📍。"
    },
    {
        id: "hw3-5",
        stem: "动态重定位是在作业的( )中进行的。",
        options: [
            { key: "A", text: "编译过程" },
            { key: "B", text: "装入过程" },
            { key: "C", text: "链接过程" },
            { key: "D", text: "执行过程" },
        ],
        answer: "D",
        type: "single",
        explain: "动态重定位是在作业的执行过程中（访问内存时）由硬件地址变换机构自动完成的。",
        mnemonic: "时间点：动态重定位发生在“运行时”⏱️，静态发生在“装入时”。"
    },
    {
        id: "hw3-6",
        stem: "在动态分区分配方案中，某一作业完成后,系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是( )。",
        options: [
            { key: "A", text: "无上邻空闲区，也无下邻空闲区" },
            { key: "B", text: "有上邻空闲区，但无下邻空闲区" },
            { key: "C", text: "有下邻空闲区，但无上邻空闲区" },
            { key: "D", text: "有上邻空闲区，也有下邻空闲区" },
        ],
        answer: "D",
        type: "single",
        explain: "回收内存时，如果有上邻空闲区，也有下邻空闲区，则三合一，空闲区表项减1。",
        mnemonic: "合并逻辑：三个小块变一个大块，账本上的记录反而少了一条📝。"
    },
    {
        id: "hw3-7",
        stem: "下面的存储管理方案中，( )方式可以采用静态重定位。",
        options: [
            { key: "A", text: "固定分区" },
            { key: "B", text: "可变分区" },
            { key: "C", text: "页式" },
            { key: "D", text: "段式" },
        ],
        answer: "A",
        type: "single",
        explain: "固定分区方式在作业装入时就确定了内存位置，且不再改变，因此可以采用静态重定位。",
        mnemonic: "特性关联：固定分区 = 钉子户🏠，进去了就不挪窝（静态重定位）。"
    },
    {
        id: "hw3-8",
        stem: "不会产生内部碎片的存储管理是( )。",
        options: [
            { key: "A", text: "分页" },
            { key: "B", text: "分段" },
            { key: "C", text: "段页式" },
            { key: "D", text: "固定分区" },
        ],
        answer: "B",
        type: "single",
        explain: "分段管理方式按逻辑分段，无内部碎片（但有外部碎片）。分页有内部碎片。",
        mnemonic: "对比：分段像量身定做👔（无内碎）；分页像买均码衣服（有内碎）。"
    },
    {
        id: "hw3-9",
        stem: "在不使用快表的情况下，基本段页式内存管理系统中，访问一条指令需要几次访问内存? ( )。",
        options: [
            { key: "A", text: "3" },
            { key: "B", text: "0" },
            { key: "C", text: "1" },
            { key: "D", text: "2" },
        ],
        answer: "A",
        type: "single",
        explain: "段页式访问需三次：1. 查段表；2. 查页表；3. 访问内存数据。",
        mnemonic: "层级结构：段页式是三层楼🏬，得爬三次才能拿到数据。"
    },
    {
        id: "hw3-10",
        stem: "虚拟存储管理系统的基础是程序的( )理论。",
        options: [
            { key: "A", text: "动态性" },
            { key: "B", text: "虚拟性" },
            { key: "C", text: "局部性" },
            { key: "D", text: "全局性" },
        ],
        answer: "C",
        type: "single",
        explain: "虚拟存储管理系统的基础是程序的局部性理论（时间局部性和空间局部性）。",
        mnemonic: "理论基石：虚存能实现，全靠程序自己“不乱跑”（局部性🏠）。"
    },
    {
        id: "hw3-11",
        stem: "对于采用虚拟内存管理方式的系统，下列关于进程虚拟地址空间的叙述中，错误的是( )。",
        options: [
            { key: "A", text: "每个进程都有自已独立的虚拟地址空间" },
            { key: "B", text: "C语言中malloc()函数返回的是虚拟地址" },
            { key: "C", text: "进程对数据段和代码段可以有不同的访问权限" },
            { key: "D", text: "虚拟地址的大小由主存和硬盘的大小决定" },
        ],
        answer: "D",
        type: "single",
        explain: "管理空闲磁盘块的数据结构包括：位图、空闲链表、FAT。索引节点用于文件元数据管理。",
        mnemonic: "归类：inode是管“有主”的，位图是管“无主”的（空闲区）⬜️。"
    },
    {
        id: "hw3-12",
        stem: "下列选项中，不会影响系统缺页率的是( )。",
        options: [
            { key: "A", text: "页置换算法" },
            { key: "B", text: "工作集的大小" },
            { key: "C", text: "进程的数量" },
            { key: "D", text: "页缓冲队列的长度" },
        ],
        answer: "D",
        type: "single",
        explain: "页缓冲队列的长度主要用于优化写回效率，不直接影响系统缺页率。",
        mnemonic: "因果辨析：缓冲队列只是个缓存区📦，改变不了你“缺页”的命运。"
    },
    {
        id: "hw3-14",
        stem: "某进程访问的页 b 不在内存中，导致产生缺页异常，该缺页异常处理过程中不一定包含的操作是( )。",
        options: [
            { key: "A", text: "淘汰内存中的页" },
            { key: "B", text: "建立页号与页框号的对应关系" },
            { key: "C", text: "将页 b 从外存读入内存" },
            { key: "D", text: "修改页表中页 b 对应的存在位" },
        ],
        answer: "A",
        type: "single",
        explain: "缺页处理不一定包含淘汰内存中的页。如果内存中有空闲页框，则直接调入，无需淘汰。",
        mnemonic: "逻辑漏洞：只有没地儿住了才赶人（淘汰），有空房直接住🏨。"
    },
    {
        id: "hw3-15",
        stem: "多进程能在主存中彼此互不干扰的环境下运行，OS是通过( )来实现的。",
        options: [
            { key: "A", text: "内存分配" },
            { key: "B", text: "内存保护" },
            { key: "C", text: "内存扩充" },
            { key: "D", text: "地址映射" },
        ],
        answer: "B",
        type: "single",
        explain: "多进程在主存中互不干扰，是通过内存保护机制来实现的。",
        mnemonic: "安全机制：内存保护就是给每个进程家里装个防盗门🚪。"
    },
    {
        id: "hw3-16",
        stem: "在缺页处理过程中，操作系统执行的操作可能是( )。\n\t①修改页表②磁盘I/O③分配页框",
        options: [
            { key: "A", text: "仅①、②" },
            { key: "B", text: "仅②" },
            { key: "C", text: "仅③" },
            { key: "D", text: "①、②、③" },
        ],
        answer: "D",
        type: "single",
        explain: "缺页处理过程中可能执行：修改页表、磁盘I/O、分配页框。",
        mnemonic: "流程概括：缺页了？得找房（分配）、搬家（I/O）、改户口（页表）📝。"
    },
    {
        id: "hw3-18",
        stem: "在采用二级页表的分页系统中，CPU页表基址寄存器中的内容是( )。",
        options: [
            { key: "A", text: "当前进程的一级页表的起始虚拟地址" },
            { key: "B", text: "当前进程的一级页表的起始物理地址" },
            { key: "C", text: "当前进程的二级页表的起始虚拟地址" },
            { key: "D", text: "当前进程的二级页表的起始物理地址" },
        ],
        answer: "B",
        type: "single",
        explain: "CPU页表基址寄存器（PTBR）中的内容是当前进程的一级页表的起始物理地址。",
        mnemonic: "寄存器内容：PTBR存的是“真地址”（物理），不是“假地址”（虚拟）📍。"
    },
    {
        id: "hw3-20",
        stem: "在可变式分区存储管理中的紧凑技术可以( )。",
        options: [
            { key: "A", text: "集中空闲区" },
            { key: "B", text: "增加主存容量" },
            { key: "C", text: "缩短访问周期" },
            { key: "D", text: "加速地址转换" },
        ],
        answer: "A",
        type: "single",
        explain: "在可变式分区存储管理中的紧凑技术可以集中空闲区。",
        mnemonic: "动作形象：紧凑就是把内存里的空隙全都“挤”到一起去🙌。"
    },
    {
        id: "hw3-21",
        stem: "虚拟存储管理策略可以( )。",
        options: [
            { key: "A", text: "扩大逻辑内存容量" },
            { key: "B", text: "扩大物理内存容量" },
            { key: "C", text: "扩大逻辑外存容量" },
            { key: "D", text: "扩大物理外存容量" },
        ],
        answer: "A",
        type: "single",
        explain: "虚拟存储管理策略可以扩大逻辑内存容量。",
        mnemonic: "核心功能：虚存就是让 4G 内存看起来像 4TB 那么大🌌。"
    },
    {
        id: "hw3-22",
        stem: "一般情况下，请求分页存储管理方式中，页面大小增加一倍则缺页中断次数( )。",
        options: [
            { key: "A", text: "增加" },
            { key: "B", text: "减少" },
            { key: "C", text: "不变" },
            { key: "D", text: "可能增加也可能减少" },
        ],
        answer: "B",
        type: "single",
        explain: "一般情况下，页面大小增加，根据局部性原理，缺页中断次数会减少。",
        mnemonic: "趋势：页大 = 碗大🥣，盛一次饭能吃更久（缺页少）。"
    },
    {
        id: "hw3-23",
        stem: "下列选项中，属于多级页表优点的是( )。",
        options: [
            { key: "A", text: "加快地址变换速度" },
            { key: "B", text: "减少缺页中断次数" },
            { key: "C", text: "减少页表项所占字节数" },
            { key: "D", text: "减少页表所占的连续内存空间" },
        ],
        answer: "D",
        type: "single",
        explain: "多级页表的主要优点是减少了页表所占的连续内存空间。",
        mnemonic: "解决痛点：多级页表就是为了不让页表占一大块连续的地皮🗺️。"
    },
    {
        id: "hw3-24",
        stem: "在虚拟存储系统中，若进程在内存中占3块(开始时为空)，采用先进先出页面淘汰算法，当执行访问页号序列为1、2、3、4、1、2、5、1、2、3、4、5、6时，将产生( )次缺页中断。",
        options: [
            { key: "A", text: "7" },
            { key: "B", text: "8" },
            { key: "C", text: "9" },
            { key: "D", text: "10" },
        ],
        answer: "D",
        type: "single",
        explain: "FIFO, 3页框。序列: 1,2,3,4,1,2,5,1,2,3,4,5,6。缺页时刻：1,2,3(满),4(1出),1(2出),2(3出),5(4出),3(1出),4(2出),6(5出)。共10次缺页。",
        mnemonic: "FIFO特征：虽然简单，但总是很无情地把老朋友赶走👋。"
    },
    {
        id: "hw3-11",
        stem: "下列选项中，可用于文件系统管理空闲磁盘块的数据结构是( )。\n\t①位图 ②索引节点 ③空闲磁盘块链IV.文件分配表(FAT)",
        options: [
            { key: "A", text: "仅①②" },
            { key: "B", text: "仅①③④" },
            { key: "C", text: "仅①③" },
            { key: "D", text: "仅②③④" },
        ],
        answer: "B",
        type: "single",
        explain: "管理空闲磁盘块的数据结构包括：位图、空闲链表、FAT。索引节点用于文件元数据管理。"
    }
];

export const getQuestionBankStats = () => {
    return {
        total: 143,
        single: 143,
        multi: 0,
        boolean: 0,
        fill: 0,
        essay: 0,
        isComplete: true
    };
};

// 辅助函数
export const getQuestionById = (id: string) => {
    return rawQuestions.find(q => q.id === id);
};

export const getQuestionsByChapter = (chapter: string) => {
    return rawQuestions.filter(q => q.id.startsWith(chapter));
};

export const getRandomQuestions = (count: number) => {
    const shuffled = [...rawQuestions].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
};

export const getExamQuestions = () => {
    return rawQuestions;
};
